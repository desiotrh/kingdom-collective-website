import React, { useState, useRef, useEffect } from 'react';
import {
    View,
    Text,
    StyleSheet,
    ScrollView,
    TouchableOpacity,
    Alert,
    ActivityIndicator,
    Dimensions,
    Share,
    Platform,
    Switch,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { LinearGradient } from 'expo-linear-gradient';
import { Camera } from 'expo-camera';
import { Audio } from 'expo-av';
import { useAuth } from '../../contexts/AuthContext';
import { useFaithMode } from '../../contexts/FaithModeContext';
import { KingdomColors } from '../../constants/KingdomColors';
import { KingdomShadows } from '../../constants/KingdomShadows';
import { useTierSystem } from '../../contexts/TierSystemContext';
import { VideoRecordingService } from '../../services/VideoRecordingService';

const { width, height } = Dimensions.get('window');

interface RecordingSession {
    id: string;
    title: string;
    duration: number;
    participants: string[];
    recordingType: 'podcast' | 'interview' | 'teaching' | 'testimony' | 'live-stream';
    faithMode: boolean;
    createdAt: Date;
    status: 'recording' | 'paused' | 'completed' | 'processing' | 'live-streaming';
    liveStreamPlatform?: 'youtube' | 'facebook' | 'instagram' | 'tiktok' | 'linkedin';
    // New Riverside.fm features
    multitrackEnabled: boolean;
    progressiveUpload: boolean;
    aiSpeakerDetection: boolean;
    greenRoomEnabled: boolean;
    producerMode: boolean;
    teamRoles: TeamRole[];
    cloudStorage: CloudStorageInfo;
}

interface TeamRole {
    id: string;
    userId: string;
    role: 'host' | 'producer' | 'editor' | 'guest';
    permissions: string[];
    isActive: boolean;
}

interface CloudStorageInfo {
    sessionId: string;
    files: CloudFile[];
    totalSize: number;
    lastBackup: Date;
    encryptionEnabled: boolean;
}

interface CloudFile {
    id: string;
    name: string;
    type: 'audio' | 'video' | 'transcript' | 'summary';
    size: number;
    url: string;
    uploadedAt: Date;
    participantId?: string;
}

interface RecordingSettings {
    quality: 'hd' | '4k';
    audioQuality: 'standard' | 'high' | 'studio';
    recordingType: 'podcast' | 'interview' | 'teaching' | 'testimony' | 'live-stream';
    faithMode: boolean;
    enableTranscription: boolean;
    enableAutoEdit: boolean;
    enableFillerWordRemoval: boolean;
    enableAutoReelsCreation: boolean;
    enableLiveStreaming: boolean;
    liveStreamPlatform?: 'youtube' | 'facebook' | 'instagram' | 'tiktok' | 'linkedin';
    // New Riverside.fm settings
    enableMultitrack: boolean;
    enableProgressiveUpload: boolean;
    enableAISpeakerDetection: boolean;
    enableGreenRoom: boolean;
    enableProducerMode: boolean;
    enableTextBasedEditing: boolean;
    enableAutoLeveling: boolean;
    enableNoiseReduction: boolean;
    enableCustomBranding: boolean;
    enableLiveCallIn: boolean;
    enableTeamRoles: boolean;
    enableCloudStorage: boolean;
    enableEncryption: boolean;
    enableFailSafeBackups: boolean;
}

interface AutoGeneratedContent {
    id: string;
    type: 'reel' | 'story' | 'short';
    platform: 'instagram' | 'tiktok' | 'youtube' | 'facebook';
    duration: number;
    thumbnail: string;
    status: 'generating' | 'completed' | 'failed';
    createdAt: Date;
}

interface GreenRoomParticipant {
    id: string;
    name: string;
    audioTest: boolean;
    videoTest: boolean;
    background: string;
    isReady: boolean;
    joinTime?: Date;
}

interface TextBasedEdit {
    id: string;
    timestamp: number;
    originalText: string;
    editedText: string;
    action: 'delete' | 'replace' | 'add';
    participantId?: string;
}

export const VideoStudioRecorderScreen: React.FC = () => {
    const { user } = useAuth();
    const { faithMode } = useFaithMode();
    const { currentTier, checkFeatureAccess, getRemainingUsage } = useTierSystem();

    const [hasPermission, setHasPermission] = useState<boolean | null>(null);
    const [isRecording, setIsRecording] = useState(false);
    const [isLiveStreaming, setIsLiveStreaming] = useState(false);
    const [recordingTime, setRecordingTime] = useState(0);
    const [currentSession, setCurrentSession] = useState<RecordingSession | null>(null);
    const [settings, setSettings] = useState<RecordingSettings>({
        quality: 'hd',
        audioQuality: 'high',
        recordingType: 'podcast',
        faithMode: faithMode,
        enableTranscription: true,
        enableAutoEdit: false,
        enableFillerWordRemoval: false,
        enableAutoReelsCreation: false,
        enableLiveStreaming: false,
        // New Riverside.fm settings
        enableMultitrack: true,
        enableProgressiveUpload: true,
        enableAISpeakerDetection: true,
        enableGreenRoom: true,
        enableProducerMode: false,
        enableTextBasedEditing: true,
        enableAutoLeveling: true,
        enableNoiseReduction: true,
        enableCustomBranding: false,
        enableLiveCallIn: false,
        enableTeamRoles: false,
        enableCloudStorage: true,
        enableEncryption: true,
        enableFailSafeBackups: true,
    });

    const [sessions, setSessions] = useState<RecordingSession[]>([]);
    const [autoGeneratedContent, setAutoGeneratedContent] = useState<AutoGeneratedContent[]>([]);
    const [isProcessing, setIsProcessing] = useState(false);
    const [isGeneratingContent, setIsGeneratingContent] = useState(false);
    const [inviteLink, setInviteLink] = useState<string | null>(null);
    // New Riverside.fm state
    const [greenRoomParticipants, setGreenRoomParticipants] = useState<GreenRoomParticipant[]>([]);
    const [textBasedEdits, setTextBasedEdits] = useState<TextBasedEdit[]>([]);
    const [isInGreenRoom, setIsInGreenRoom] = useState(false);
    const [isProducerMode, setIsProducerMode] = useState(false);
    const [teamRoles, setTeamRoles] = useState<TeamRole[]>([]);
    const [cloudFiles, setCloudFiles] = useState<CloudFile[]>([]);
    const [isUploading, setIsUploading] = useState(false);
    const [uploadProgress, setUploadProgress] = useState(0);

    const videoRecordingService = useRef(new VideoRecordingService()).current;
    const recordingInterval = useRef<NodeJS.Timeout | null>(null);

    // Tier-based feature access
    const canRecordVideo = currentTier === 'commissioned' || currentTier === 'mantled_pro' || currentTier === 'kingdom_enterprise';
    const canLiveStream = currentTier === 'kingdom_enterprise';
    const canUseAI = currentTier === 'commissioned' || currentTier === 'mantled_pro' || currentTier === 'kingdom_enterprise';
    const remainingCredits = 60; // Mock value for now
    const maxRecordingHours = currentTier === 'kingdom_enterprise' ? 10 : currentTier === 'mantled_pro' ? 5 : 1;

    const recordingTypeOptions = [
        { value: 'podcast', label: 'Podcast', icon: '🎙️', description: 'Multi-guest podcast recording' },
        { value: 'interview', label: 'Interview', icon: '🎤', description: 'One-on-one interview' },
        { value: 'teaching', label: 'Teaching', icon: '📚', description: 'Educational content' },
        { value: 'testimony', label: 'Testimony', icon: '🙏', description: 'Faith-based testimony' },
        { value: 'live-stream', label: 'Live Stream', icon: '📡', description: 'Live streaming to social media', premium: true },
    ];

    const liveStreamPlatforms = [
        { value: 'youtube', label: 'YouTube Live', icon: '📺', color: '#FF0000' },
        { value: 'facebook', label: 'Facebook Live', icon: '📘', color: '#1877F2' },
        { value: 'instagram', label: 'Instagram Live', icon: '📷', color: '#E4405F' },
        { value: 'tiktok', label: 'TikTok Live', icon: '🎵', color: '#000000' },
        { value: 'linkedin', label: 'LinkedIn Live', icon: '💼', color: '#0A66C2' },
    ];

    const qualityOptions = [
        { value: 'hd', label: 'HD (1080p)', icon: '📹' },
        { value: '4k', label: '4K Ultra HD', icon: '🎬' },
    ];

    const audioQualityOptions = [
        { value: 'standard', label: 'Standard', icon: '🔊' },
        { value: 'high', label: 'High Quality', icon: '🎵' },
        { value: 'studio', label: 'Studio Quality', icon: '🎛️' },
    ];

    useEffect(() => {
        requestPermissions();
        return () => {
            if (recordingInterval.current) {
                clearInterval(recordingInterval.current);
            }
        };
    }, []);

    const requestPermissions = async () => {
        try {
            const { status: cameraStatus } = await Camera.requestCameraPermissionsAsync();
            const { status: audioStatus } = await Audio.requestPermissionsAsync();

            setHasPermission(cameraStatus === 'granted' && audioStatus === 'granted');
        } catch (error) {
            console.error('Permission request error:', error);
            setHasPermission(false);
        }
    };

    const startRecording = async () => {
        if (!hasPermission) {
            Alert.alert('Permissions Required', 'Camera and microphone permissions are required for recording.');
            return;
        }

        if (!canRecordVideo) {
            Alert.alert('Feature Unavailable', 'Video recording requires a Pro or Enterprise subscription.');
            return;
        }

        try {
            const sessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

            const newSession: RecordingSession = {
                id: sessionId,
                title: `${settings.recordingType.charAt(0).toUpperCase() + settings.recordingType.slice(1)} Recording`,
                duration: 0,
                participants: ['You'],
                recordingType: settings.recordingType,
                faithMode: settings.faithMode,
                createdAt: new Date(),
                status: settings.recordingType === 'live-stream' ? 'live-streaming' : 'recording',
                liveStreamPlatform: settings.liveStreamPlatform,
                // New Riverside.fm features
                multitrackEnabled: settings.enableMultitrack,
                progressiveUpload: settings.enableProgressiveUpload,
                aiSpeakerDetection: settings.enableAISpeakerDetection,
                greenRoomEnabled: settings.enableGreenRoom,
                producerMode: settings.enableProducerMode,
                teamRoles: [],
                cloudStorage: {
                    sessionId: sessionId,
                    files: [],
                    totalSize: 0,
                    lastBackup: new Date(),
                    encryptionEnabled: settings.enableEncryption,
                },
            };

            setCurrentSession(newSession);
            setIsRecording(true);
            setRecordingTime(0);

            // Start recording timer
            recordingInterval.current = setInterval(() => {
                setRecordingTime(prev => prev + 1);
            }, 1000);

            if (settings.recordingType === 'live-stream') {
                await startLiveStream(newSession);
            }

            Alert.alert(
                settings.recordingType === 'live-stream' ? 'Live Stream Started' : 'Recording Started',
                settings.recordingType === 'live-stream'
                    ? `Your live stream is now broadcasting to ${settings.liveStreamPlatform}.`
                    : 'Your video recording has begun. Tap the stop button when finished.'
            );

        } catch (error) {
            console.error('Recording start error:', error);
            Alert.alert('Recording Failed', 'Failed to start recording. Please try again.');
        }
    };

    const startLiveStream = async (session: RecordingSession) => {
        try {
            setIsLiveStreaming(true);
            // Simulate live streaming to social media platform
            console.log(`Starting live stream to ${session.liveStreamPlatform}`);

            // Here you would integrate with social media APIs
            // YouTube Live API, Facebook Live API, Instagram Live API, etc.

        } catch (error) {
            console.error('Live stream start error:', error);
            Alert.alert('Live Stream Failed', 'Failed to start live stream. Please try again.');
        }
    };

    const stopRecording = async () => {
        if (!currentSession) return;

        try {
            setIsRecording(false);
            setIsLiveStreaming(false);

            if (recordingInterval.current) {
                clearInterval(recordingInterval.current);
                recordingInterval.current = null;
            }

            // Update session with final duration
            const updatedSession: RecordingSession = {
                ...currentSession,
                duration: recordingTime,
                status: 'processing',
            };

            setSessions(prev => [updatedSession, ...prev]);
            setCurrentSession(null);
            setRecordingTime(0);

            // Process recording with AI features
            setIsProcessing(true);
            await processRecording(updatedSession);
            setIsProcessing(false);

            // Auto-generate content if enabled
            if (settings.enableAutoReelsCreation) {
                await generateAutoContent(updatedSession);
            }

            Alert.alert(
                'Recording Complete',
                'Your recording has been saved and is being processed with AI enhancements.',
                [
                    { text: 'View Auto-Generated Content', onPress: () => showAutoGeneratedContent() },
                    { text: 'OK' }
                ]
            );

        } catch (error) {
            console.error('Recording stop error:', error);
            Alert.alert('Recording Error', 'Failed to stop recording. Please try again.');
        }
    };

    const processRecording = async (session: RecordingSession) => {
        try {
            // AI Processing Pipeline
            const processingSteps = [];

            if (settings.enableTranscription) {
                processingSteps.push('Transcribing audio...');
            }

            if (settings.enableFillerWordRemoval) {
                processingSteps.push('Removing filler words...');
            }

            if (settings.enableAutoEdit) {
                processingSteps.push('Auto-editing content...');
            }

            // Simulate AI processing
            for (const step of processingSteps) {
                console.log(step);
                await new Promise(resolve => setTimeout(resolve, 2000));
            }

            console.log('Recording processed with AI enhancements:', session.id);
        } catch (error) {
            console.error('Recording processing error:', error);
        }
    };

    const generateAutoContent = async (session: RecordingSession) => {
        try {
            setIsGeneratingContent(true);

            const platforms = ['instagram', 'tiktok', 'youtube', 'facebook'];
            const contentTypes = ['reel', 'story', 'short'];

            const newContent: AutoGeneratedContent[] = [];

            for (const platform of platforms) {
                for (const contentType of contentTypes) {
                    const content: AutoGeneratedContent = {
                        id: `content_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                        type: contentType as any,
                        platform: platform as any,
                        duration: Math.floor(Math.random() * 60) + 15, // 15-75 seconds
                        thumbnail: `https://picsum.photos/300/400?random=${Math.random()}`,
                        status: 'generating',
                        createdAt: new Date(),
                    };

                    newContent.push(content);
                }
            }

            setAutoGeneratedContent(prev => [...newContent, ...prev]);

            // Simulate AI content generation
            await new Promise(resolve => setTimeout(resolve, 3000));

            // Update status to completed
            setAutoGeneratedContent(prev =>
                prev.map(content => ({ ...content, status: 'completed' as any }))
            );

            setIsGeneratingContent(false);

        } catch (error) {
            console.error('Auto content generation error:', error);
            setIsGeneratingContent(false);
        }
    };

    const showAutoGeneratedContent = () => {
        Alert.alert(
            'Auto-Generated Content',
            `Generated ${autoGeneratedContent.length} pieces of content from your video:\n\n` +
            autoGeneratedContent.map(content =>
                `${content.platform} ${content.type} (${content.duration}s)`
            ).join('\n'),
            [
                { text: 'View All', onPress: () => {/* Navigate to content library */ } },
                { text: 'OK' }
            ]
        );
    };

    // New Riverside.fm functions
    const enterGreenRoom = async () => {
        setIsInGreenRoom(true);
        Alert.alert('Green Room', 'Test your audio and video before joining the session.');
    };

    const testAudioVideo = async () => {
        try {
            // Simulate audio/video test
            await new Promise(resolve => setTimeout(resolve, 2000));
            Alert.alert('Test Complete', 'Audio and video are working correctly!');
        } catch (error) {
            Alert.alert('Test Failed', 'Please check your microphone and camera settings.');
        }
    };

    const toggleProducerMode = () => {
        setIsProducerMode(!isProducerMode);
        Alert.alert(
            isProducerMode ? 'Producer Mode Disabled' : 'Producer Mode Enabled',
            isProducerMode ? 'You can now be recorded in the session.' : 'You can control the session without being recorded.'
        );
    };

    const addTeamRole = (userId: string, role: 'host' | 'producer' | 'editor' | 'guest') => {
        const newRole: TeamRole = {
            id: `role_${Date.now()}`,
            userId,
            role,
            permissions: role === 'host' ? ['all'] : role === 'producer' ? ['control', 'edit'] : role === 'editor' ? ['edit'] : ['view'],
            isActive: true,
        };
        setTeamRoles(prev => [...prev, newRole]);
    };

    const startProgressiveUpload = async () => {
        setIsUploading(true);
        setUploadProgress(0);

        // Simulate progressive upload
        const uploadInterval = setInterval(() => {
            setUploadProgress(prev => {
                if (prev >= 100) {
                    clearInterval(uploadInterval);
                    setIsUploading(false);
                    return 100;
                }
                return prev + 10;
            });
        }, 500);
    };

    const editTextBasedVideo = (timestamp: number, originalText: string, editedText: string) => {
        const edit: TextBasedEdit = {
            id: `edit_${Date.now()}`,
            timestamp,
            originalText,
            editedText,
            action: 'replace',
        };
        setTextBasedEdits(prev => [...prev, edit]);
        Alert.alert('Edit Applied', 'Text-based edit has been applied to the video.');
    };

    const manageCloudStorage = () => {
        Alert.alert(
            'Cloud Storage',
            `Total Files: ${cloudFiles.length}\nTotal Size: ${cloudFiles.reduce((sum, file) => sum + file.size, 0)} MB\nLast Backup: ${new Date().toLocaleDateString()}`,
            [
                { text: 'View Files', onPress: () => {/* Navigate to file browser */ } },
                { text: 'Backup Now', onPress: () => startProgressiveUpload() },
                { text: 'OK' }
            ]
        );
    };

    const enableAISpeakerDetection = () => {
        Alert.alert('AI Speaker Detection', 'AI will automatically switch camera focus based on who is speaking.');
    };

    const enableCustomBranding = () => {
        Alert.alert('Custom Branding', 'Add your logo, overlays, intros, and outros to recordings.');
    };

    const enableLiveCallIn = () => {
        Alert.alert('Live Call-In', 'Allow live listeners to call in or comment during your stream.');
    };

    const generateInviteLink = async () => {
        if (!currentSession) return;

        try {
            const link = `https://kingdomstudios.app/join-recording/${currentSession.id}?type=${settings.recordingType}&max=5`;
            setInviteLink(link);

            Alert.alert(
                'Invite Link Generated',
                'Share this link with your guests to join the recording session.',
                [
                    { text: 'Copy Link', onPress: () => {/* Copy to clipboard */ } },
                    { text: 'Share', onPress: () => shareInviteLink(link) },
                    { text: 'OK' },
                ]
            );
        } catch (error) {
            Alert.alert('Error', 'Failed to generate invite link. Please try again.');
        }
    };

    const shareInviteLink = async (link: string) => {
        try {
            await Share.share({
                url: link,
                message: `Join my ${settings.recordingType} recording session: ${link}`,
            });
        } catch (error) {
            Alert.alert('Error', 'Failed to share invite link.');
        }
    };

    const formatTime = (seconds: number): string => {
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        const secs = seconds % 60;
        return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    };

    const renderRecordingControls = () => (
        <View style={styles.recordingSection}>
            <View style={styles.recordingInfo}>
                <Text style={styles.recordingTitle}>
                    {currentSession?.title || 'Ready to Record'}
                </Text>
                <Text style={styles.recordingTime}>
                    {formatTime(recordingTime)}
                </Text>
                {isLiveStreaming && (
                    <View style={styles.liveIndicator}>
                        <Text style={styles.liveText}>🔴 LIVE</Text>
                        <Text style={styles.platformText}>
                            Streaming to {settings.liveStreamPlatform}
                        </Text>
                    </View>
                )}
            </View>

            <View style={styles.controlButtons}>
                {!isRecording ? (
                    <TouchableOpacity
                        style={[
                            styles.recordButton,
                            !canRecordVideo && styles.disabledButton
                        ]}
                        onPress={startRecording}
                        disabled={!canRecordVideo}
                    >
                        <Text style={styles.recordButtonText}>
                            {settings.recordingType === 'live-stream' ? '🔴 Go Live' : '🎙️ Start Recording'}
                        </Text>
                    </TouchableOpacity>
                ) : (
                    <TouchableOpacity
                        style={styles.stopButton}
                        onPress={stopRecording}
                    >
                        <Text style={styles.stopButtonText}>⏹️ Stop</Text>
                    </TouchableOpacity>
                )}

                {isRecording && (
                    <TouchableOpacity
                        style={styles.inviteButton}
                        onPress={generateInviteLink}
                    >
                        <Text style={styles.inviteButtonText}>👥 Invite Guests</Text>
                    </TouchableOpacity>
                )}
            </View>
        </View>
    );

    const renderAdvancedSettings = () => (
        <View style={styles.settingsSection}>
            <Text style={styles.sectionTitle}>Advanced AI Features</Text>

            {/* AI Filler Word Removal */}
            <View style={styles.settingRow}>
                <View style={styles.settingInfo}>
                    <Text style={styles.settingLabel}>AI Filler Word Removal</Text>
                    <Text style={styles.settingDescription}>
                        Automatically remove "um", "uh", "like", "you know" from audio
                    </Text>
                </View>
                <Switch
                    value={settings.enableFillerWordRemoval}
                    onValueChange={(value) => setSettings(prev => ({ ...prev, enableFillerWordRemoval: value }))}
                    disabled={!canUseAI}
                    trackColor={{ false: KingdomColors.border, true: KingdomColors.primary }}
                    thumbColor={settings.enableFillerWordRemoval ? KingdomColors.white : KingdomColors.textSecondary}
                />
            </View>

            {/* Auto Edit */}
            <View style={styles.settingRow}>
                <View style={styles.settingInfo}>
                    <Text style={styles.settingLabel}>AI Auto Edit</Text>
                    <Text style={styles.settingDescription}>
                        Automatically edit out silence and improve pacing
                    </Text>
                </View>
                <Switch
                    value={settings.enableAutoEdit}
                    onValueChange={(value) => setSettings(prev => ({ ...prev, enableAutoEdit: value }))}
                    disabled={!canUseAI}
                    trackColor={{ false: KingdomColors.border, true: KingdomColors.primary }}
                    thumbColor={settings.enableAutoEdit ? KingdomColors.white : KingdomColors.textSecondary}
                />
            </View>

            {/* Auto Reels Creation */}
            <View style={styles.settingRow}>
                <View style={styles.settingInfo}>
                    <Text style={styles.settingLabel}>Auto-Create Reels/Stories</Text>
                    <Text style={styles.settingDescription}>
                        AI automatically creates reels, stories, and shorts from your video
                    </Text>
                </View>
                <Switch
                    value={settings.enableAutoReelsCreation}
                    onValueChange={(value) => setSettings(prev => ({ ...prev, enableAutoReelsCreation: value }))}
                    disabled={!canUseAI}
                    trackColor={{ false: KingdomColors.border, true: KingdomColors.primary }}
                    thumbColor={settings.enableAutoReelsCreation ? KingdomColors.white : KingdomColors.textSecondary}
                />
            </View>

            {/* Live Streaming */}
            <View style={styles.settingRow}>
                <View style={styles.settingInfo}>
                    <Text style={styles.settingLabel}>Live Streaming</Text>
                    <Text style={styles.settingDescription}>
                        Stream directly to social media platforms
                    </Text>
                </View>
                <Switch
                    value={settings.enableLiveStreaming}
                    onValueChange={(value) => setSettings(prev => ({ ...prev, enableLiveStreaming: value }))}
                    disabled={!canLiveStream}
                    trackColor={{ false: KingdomColors.border, true: KingdomColors.primary }}
                    thumbColor={settings.enableLiveStreaming ? KingdomColors.white : KingdomColors.textSecondary}
                />
            </View>

            {/* Live Stream Platform Selection */}
            {settings.enableLiveStreaming && (
                <View style={styles.platformSection}>
                    <Text style={styles.settingLabel}>Live Stream Platform</Text>
                    <ScrollView horizontal showsHorizontalScrollIndicator={false} style={styles.platformsContainer}>
                        {liveStreamPlatforms.map((platform) => (
                            <TouchableOpacity
                                key={platform.value}
                                style={[
                                    styles.platformButton,
                                    settings.liveStreamPlatform === platform.value && styles.platformButtonSelected
                                ]}
                                onPress={() => setSettings(prev => ({ ...prev, liveStreamPlatform: platform.value as any }))}
                            >
                                <Text style={styles.platformIcon}>{platform.icon}</Text>
                                <Text style={[
                                    styles.platformLabel,
                                    settings.liveStreamPlatform === platform.value && styles.platformLabelSelected
                                ]}>
                                    {platform.label}
                                </Text>
                            </TouchableOpacity>
                        ))}
                    </ScrollView>
                </View>
            )}
        </View>
    );

    const renderRiversideFeatures = () => (
        <View style={styles.settingsSection}>
            <Text style={styles.sectionTitle}>Riverside.fm Features</Text>

            {/* Multitrack Recording */}
            <View style={styles.settingRow}>
                <View style={styles.settingInfo}>
                    <Text style={styles.settingLabel}>Multitrack Recording</Text>
                    <Text style={styles.settingDescription}>
                        Separate audio/video tracks per participant for professional editing
                    </Text>
                </View>
                <Switch
                    value={settings.enableMultitrack}
                    onValueChange={(value) => setSettings(prev => ({ ...prev, enableMultitrack: value }))}
                    trackColor={{ false: KingdomColors.border, true: KingdomColors.primary }}
                    thumbColor={settings.enableMultitrack ? KingdomColors.white : KingdomColors.textSecondary}
                />
            </View>

            {/* Progressive Upload */}
            <View style={styles.settingRow}>
                <View style={styles.settingInfo}>
                    <Text style={styles.settingLabel}>Progressive Upload</Text>
                    <Text style={styles.settingDescription}>
                        Files upload during session to prevent data loss
                    </Text>
                </View>
                <Switch
                    value={settings.enableProgressiveUpload}
                    onValueChange={(value) => setSettings(prev => ({ ...prev, enableProgressiveUpload: value }))}
                    trackColor={{ false: KingdomColors.border, true: KingdomColors.primary }}
                    thumbColor={settings.enableProgressiveUpload ? KingdomColors.white : KingdomColors.textSecondary}
                />
            </View>

            {/* AI Speaker Detection */}
            <View style={styles.settingRow}>
                <View style={styles.settingInfo}>
                    <Text style={styles.settingLabel}>AI Speaker Detection</Text>
                    <Text style={styles.settingDescription}>
                        Auto-layout switching based on who is talking
                    </Text>
                </View>
                <Switch
                    value={settings.enableAISpeakerDetection}
                    onValueChange={(value) => setSettings(prev => ({ ...prev, enableAISpeakerDetection: value }))}
                    trackColor={{ false: KingdomColors.border, true: KingdomColors.primary }}
                    thumbColor={settings.enableAISpeakerDetection ? KingdomColors.white : KingdomColors.textSecondary}
                />
            </View>

            {/* Green Room */}
            <View style={styles.settingRow}>
                <View style={styles.settingInfo}>
                    <Text style={styles.settingLabel}>Green Room</Text>
                    <Text style={styles.settingDescription}>
                        Test audio/video before joining the session
                    </Text>
                </View>
                <Switch
                    value={settings.enableGreenRoom}
                    onValueChange={(value) => setSettings(prev => ({ ...prev, enableGreenRoom: value }))}
                    trackColor={{ false: KingdomColors.border, true: KingdomColors.primary }}
                    thumbColor={settings.enableGreenRoom ? KingdomColors.white : KingdomColors.textSecondary}
                />
            </View>

            {/* Producer Mode */}
            <View style={styles.settingRow}>
                <View style={styles.settingInfo}>
                    <Text style={styles.settingLabel}>Producer Mode</Text>
                    <Text style={styles.settingDescription}>
                        Control session without being recorded
                    </Text>
                </View>
                <Switch
                    value={settings.enableProducerMode}
                    onValueChange={(value) => setSettings(prev => ({ ...prev, enableProducerMode: value }))}
                    trackColor={{ false: KingdomColors.border, true: KingdomColors.primary }}
                    thumbColor={settings.enableProducerMode ? KingdomColors.white : KingdomColors.textSecondary}
                />
            </View>

            {/* Text-Based Editing */}
            <View style={styles.settingRow}>
                <View style={styles.settingInfo}>
                    <Text style={styles.settingLabel}>Text-Based Video Editing</Text>
                    <Text style={styles.settingDescription}>
                        Edit video by editing the transcript text
                    </Text>
                </View>
                <Switch
                    value={settings.enableTextBasedEditing}
                    onValueChange={(value) => setSettings(prev => ({ ...prev, enableTextBasedEditing: value }))}
                    trackColor={{ false: KingdomColors.border, true: KingdomColors.primary }}
                    thumbColor={settings.enableTextBasedEditing ? KingdomColors.white : KingdomColors.textSecondary}
                />
            </View>

            {/* Auto Leveling & Noise Reduction */}
            <View style={styles.settingRow}>
                <View style={styles.settingInfo}>
                    <Text style={styles.settingLabel}>Auto Leveling & Noise Reduction</Text>
                    <Text style={styles.settingDescription}>
                        Automatically improve audio quality and remove background noise
                    </Text>
                </View>
                <Switch
                    value={settings.enableAutoLeveling && settings.enableNoiseReduction}
                    onValueChange={(value) => setSettings(prev => ({
                        ...prev,
                        enableAutoLeveling: value,
                        enableNoiseReduction: value
                    }))}
                    trackColor={{ false: KingdomColors.border, true: KingdomColors.primary }}
                    thumbColor={(settings.enableAutoLeveling && settings.enableNoiseReduction) ? KingdomColors.white : KingdomColors.textSecondary}
                />
            </View>

            {/* Custom Branding */}
            <View style={styles.settingRow}>
                <View style={styles.settingInfo}>
                    <Text style={styles.settingLabel}>Custom Branding</Text>
                    <Text style={styles.settingDescription}>
                        Add logos, overlays, intros, and outros
                    </Text>
                </View>
                <Switch
                    value={settings.enableCustomBranding}
                    onValueChange={(value) => setSettings(prev => ({ ...prev, enableCustomBranding: value }))}
                    trackColor={{ false: KingdomColors.border, true: KingdomColors.primary }}
                    thumbColor={settings.enableCustomBranding ? KingdomColors.white : KingdomColors.textSecondary}
                />
            </View>

            {/* Live Call-In */}
            <View style={styles.settingRow}>
                <View style={styles.settingInfo}>
                    <Text style={styles.settingLabel}>Live Call-In</Text>
                    <Text style={styles.settingDescription}>
                        Allow live listeners to call in or comment
                    </Text>
                </View>
                <Switch
                    value={settings.enableLiveCallIn}
                    onValueChange={(value) => setSettings(prev => ({ ...prev, enableLiveCallIn: value }))}
                    trackColor={{ false: KingdomColors.border, true: KingdomColors.primary }}
                    thumbColor={settings.enableLiveCallIn ? KingdomColors.white : KingdomColors.textSecondary}
                />
            </View>

            {/* Team Roles */}
            <View style={styles.settingRow}>
                <View style={styles.settingInfo}>
                    <Text style={styles.settingLabel}>Team Roles</Text>
                    <Text style={styles.settingDescription}>
                        Assign roles (Host, Producer, Editor) with access control
                    </Text>
                </View>
                <Switch
                    value={settings.enableTeamRoles}
                    onValueChange={(value) => setSettings(prev => ({ ...prev, enableTeamRoles: value }))}
                    trackColor={{ false: KingdomColors.border, true: KingdomColors.primary }}
                    thumbColor={settings.enableTeamRoles ? KingdomColors.white : KingdomColors.textSecondary}
                />
            </View>

            {/* Cloud Storage */}
            <View style={styles.settingRow}>
                <View style={styles.settingInfo}>
                    <Text style={styles.settingLabel}>Cloud Storage</Text>
                    <Text style={styles.settingDescription}>
                        Store episodes, assets, and brand kits with encryption
                    </Text>
                </View>
                <Switch
                    value={settings.enableCloudStorage}
                    onValueChange={(value) => setSettings(prev => ({ ...prev, enableCloudStorage: value }))}
                    trackColor={{ false: KingdomColors.border, true: KingdomColors.primary }}
                    thumbColor={settings.enableCloudStorage ? KingdomColors.white : KingdomColors.textSecondary}
                />
            </View>
        </View>
    );

    const renderSettings = () => (
        <View style={styles.settingsSection}>
            <Text style={styles.sectionTitle}>Recording Settings</Text>

            {/* Recording Type Selection */}
            <Text style={styles.settingLabel}>Recording Type</Text>
            <ScrollView horizontal showsHorizontalScrollIndicator={false} style={styles.optionsContainer}>
                {recordingTypeOptions.map((option) => (
                    <TouchableOpacity
                        key={option.value}
                        style={[
                            styles.optionCard,
                            settings.recordingType === option.value && styles.optionCardSelected,
                            option.premium && !canLiveStream && styles.premiumOption
                        ]}
                        onPress={() => {
                            if (option.premium && !canLiveStream) {
                                Alert.alert('Premium Feature', 'Live streaming requires an Enterprise subscription.');
                                return;
                            }
                            setSettings(prev => ({ ...prev, recordingType: option.value as any }));
                        }}
                    >
                        <Text style={styles.optionIcon}>{option.icon}</Text>
                        <Text style={[
                            styles.optionTitle,
                            settings.recordingType === option.value && styles.optionTitleSelected
                        ]}>
                            {option.label}
                        </Text>
                        <Text style={[
                            styles.optionDescription,
                            settings.recordingType === option.value && styles.optionDescriptionSelected
                        ]}>
                            {option.description}
                        </Text>
                        {option.premium && (
                            <Text style={styles.premiumBadge}>PRO</Text>
                        )}
                    </TouchableOpacity>
                ))}
            </ScrollView>

            {/* Video Quality */}
            <Text style={styles.settingLabel}>Video Quality</Text>
            <ScrollView horizontal showsHorizontalScrollIndicator={false} style={styles.optionsContainer}>
                {qualityOptions.map((option) => (
                    <TouchableOpacity
                        key={option.value}
                        style={[
                            styles.optionCard,
                            settings.quality === option.value && styles.optionCardSelected
                        ]}
                        onPress={() => setSettings(prev => ({ ...prev, quality: option.value as any }))}
                    >
                        <Text style={styles.optionIcon}>{option.icon}</Text>
                        <Text style={[
                            styles.optionTitle,
                            settings.quality === option.value && styles.optionTitleSelected
                        ]}>
                            {option.label}
                        </Text>
                    </TouchableOpacity>
                ))}
            </ScrollView>

            {/* Audio Quality */}
            <Text style={styles.settingLabel}>Audio Quality</Text>
            <ScrollView horizontal showsHorizontalScrollIndicator={false} style={styles.optionsContainer}>
                {audioQualityOptions.map((option) => (
                    <TouchableOpacity
                        key={option.value}
                        style={[
                            styles.optionCard,
                            settings.audioQuality === option.value && styles.optionCardSelected
                        ]}
                        onPress={() => setSettings(prev => ({ ...prev, audioQuality: option.value as any }))}
                    >
                        <Text style={styles.optionIcon}>{option.icon}</Text>
                        <Text style={[
                            styles.optionTitle,
                            settings.audioQuality === option.value && styles.optionTitleSelected
                        ]}>
                            {option.label}
                        </Text>
                    </TouchableOpacity>
                ))}
            </ScrollView>
        </View>
    );

    const renderRecentSessions = () => (
        <View style={styles.sessionsSection}>
            <Text style={styles.sectionTitle}>Recent Recordings</Text>
            <ScrollView horizontal showsHorizontalScrollIndicator={false}>
                {sessions.map((session) => (
                    <TouchableOpacity
                        key={session.id}
                        style={styles.sessionCard}
                        onPress={() => {/* Navigate to session details */ }}
                    >
                        <View style={styles.sessionHeader}>
                            <Text style={styles.sessionIcon}>
                                {session.recordingType === 'podcast' ? '🎙️' :
                                    session.recordingType === 'interview' ? '🎤' :
                                        session.recordingType === 'teaching' ? '📚' :
                                            session.recordingType === 'live-stream' ? '📡' : '🙏'}
                            </Text>
                            <Text style={styles.sessionStatus}>{session.status}</Text>
                        </View>
                        <Text style={styles.sessionTitle}>{session.title}</Text>
                        <Text style={styles.sessionDuration}>{formatTime(session.duration)}</Text>
                        <Text style={styles.sessionDate}>
                            {session.createdAt.toLocaleDateString()}
                        </Text>
                        {session.liveStreamPlatform && (
                            <Text style={styles.platformBadge}>
                                {session.liveStreamPlatform}
                            </Text>
                        )}
                    </TouchableOpacity>
                ))}
            </ScrollView>
        </View>
    );

    const renderTierInfo = () => (
        <View style={styles.tierSection}>
            <Text style={styles.sectionTitle}>Subscription Status</Text>
            <View style={styles.tierCard}>
                <Text style={styles.tierTitle}>Current Tier: {currentTier.toUpperCase()}</Text>
                <Text style={styles.tierDescription}>
                    {currentTier === 'kingdom_enterprise' ? 'Unlimited features and live streaming' :
                        currentTier === 'mantled_pro' ? 'Advanced AI features and longer recordings' :
                            'Basic recording features'}
                </Text>
                <Text style={styles.creditsText}>
                    Remaining Credits: {remainingCredits} / {maxRecordingHours * 60} minutes
                </Text>
            </View>
        </View>
    );

    if (hasPermission === null) {
        return (
            <SafeAreaView style={styles.container}>
                <View style={styles.loadingContainer}>
                    <ActivityIndicator size="large" color={KingdomColors.primary} />
                    <Text style={styles.loadingText}>Requesting permissions...</Text>
                </View>
            </SafeAreaView>
        );
    }

    if (hasPermission === false) {
        return (
            <SafeAreaView style={styles.container}>
                <View style={styles.permissionContainer}>
                    <Text style={styles.permissionTitle}>Permissions Required</Text>
                    <Text style={styles.permissionText}>
                        Camera and microphone permissions are required for video recording.
                    </Text>
                    <TouchableOpacity style={styles.permissionButton} onPress={requestPermissions}>
                        <Text style={styles.permissionButtonText}>Grant Permissions</Text>
                    </TouchableOpacity>
                </View>
            </SafeAreaView>
        );
    }

    return (
        <SafeAreaView style={styles.container}>
            <ScrollView style={styles.scrollView} showsVerticalScrollIndicator={false}>
                <View style={styles.header}>
                    <Text style={styles.title}>Video Studio Recorder</Text>
                    <Text style={styles.subtitle}>
                        Professional video recording with AI enhancements and live streaming
                    </Text>
                </View>

                {renderRecordingControls()}
                {renderSettings()}
                {renderAdvancedSettings()}
                {renderRiversideFeatures()}
                {renderRecentSessions()}
                {renderTierInfo()}
            </ScrollView>

            {isProcessing && (
                <View style={styles.processingOverlay}>
                    <ActivityIndicator size="large" color={KingdomColors.white} />
                    <Text style={styles.processingText}>Processing with AI...</Text>
                </View>
            )}

            {isGeneratingContent && (
                <View style={styles.processingOverlay}>
                    <ActivityIndicator size="large" color={KingdomColors.white} />
                    <Text style={styles.processingText}>Creating reels and stories...</Text>
                </View>
            )}
        </SafeAreaView>
    );
};

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: KingdomColors.background,
    },
    scrollView: {
        flex: 1,
    },
    header: {
        padding: 20,
        alignItems: 'center',
    },
    title: {
        fontSize: 28,
        fontWeight: 'bold',
        color: KingdomColors.text,
        marginBottom: 8,
    },
    subtitle: {
        fontSize: 16,
        color: KingdomColors.textSecondary,
        textAlign: 'center',
        lineHeight: 22,
    },
    loadingContainer: {
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center',
    },
    loadingText: {
        marginTop: 16,
        fontSize: 16,
        color: KingdomColors.textSecondary,
    },
    permissionContainer: {
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center',
        padding: 20,
    },
    permissionTitle: {
        fontSize: 24,
        fontWeight: 'bold',
        color: KingdomColors.text,
        marginBottom: 16,
    },
    permissionText: {
        fontSize: 16,
        color: KingdomColors.textSecondary,
        textAlign: 'center',
        marginBottom: 24,
        lineHeight: 22,
    },
    permissionButton: {
        backgroundColor: KingdomColors.primary,
        borderRadius: 12,
        paddingVertical: 16,
        paddingHorizontal: 32,
    },
    permissionButtonText: {
        fontSize: 18,
        fontWeight: 'bold',
        color: KingdomColors.white,
    },
    recordingSection: {
        marginHorizontal: 20,
        marginBottom: 24,
        backgroundColor: KingdomColors.surface,
        borderRadius: 16,
        padding: 20,
        ...KingdomShadows.medium,
    },
    recordingInfo: {
        alignItems: 'center',
        marginBottom: 20,
    },
    recordingTitle: {
        fontSize: 20,
        fontWeight: 'bold',
        color: KingdomColors.text,
        marginBottom: 8,
    },
    recordingTime: {
        fontSize: 32,
        fontWeight: 'bold',
        color: KingdomColors.primary,
        fontFamily: 'monospace',
    },
    liveIndicator: {
        alignItems: 'center',
        marginTop: 8,
    },
    liveText: {
        fontSize: 16,
        fontWeight: 'bold',
        color: KingdomColors.error,
    },
    platformText: {
        fontSize: 14,
        color: KingdomColors.textSecondary,
    },
    controlButtons: {
        flexDirection: 'row',
        justifyContent: 'space-around',
    },
    recordButton: {
        backgroundColor: KingdomColors.success,
        borderRadius: 12,
        paddingVertical: 16,
        paddingHorizontal: 24,
        flex: 1,
        marginHorizontal: 8,
        alignItems: 'center',
    },
    disabledButton: {
        backgroundColor: KingdomColors.textSecondary,
    },
    recordButtonText: {
        fontSize: 16,
        fontWeight: 'bold',
        color: KingdomColors.white,
    },
    stopButton: {
        backgroundColor: KingdomColors.error,
        borderRadius: 12,
        paddingVertical: 16,
        paddingHorizontal: 24,
        flex: 1,
        marginHorizontal: 8,
        alignItems: 'center',
    },
    stopButtonText: {
        fontSize: 16,
        fontWeight: 'bold',
        color: KingdomColors.white,
    },
    inviteButton: {
        backgroundColor: KingdomColors.primary,
        borderRadius: 12,
        paddingVertical: 12,
        paddingHorizontal: 16,
        marginTop: 12,
        alignItems: 'center',
    },
    inviteButtonText: {
        fontSize: 14,
        fontWeight: '600',
        color: KingdomColors.white,
    },
    settingsSection: {
        marginHorizontal: 20,
        marginBottom: 24,
    },
    sectionTitle: {
        fontSize: 20,
        fontWeight: 'bold',
        color: KingdomColors.text,
        marginBottom: 16,
    },
    settingLabel: {
        fontSize: 16,
        fontWeight: '600',
        color: KingdomColors.text,
        marginBottom: 12,
        marginTop: 16,
    },
    settingRow: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'center',
        paddingVertical: 12,
        borderBottomWidth: 1,
        borderBottomColor: KingdomColors.border,
    },
    settingInfo: {
        flex: 1,
        marginRight: 16,
    },
    settingDescription: {
        fontSize: 14,
        color: KingdomColors.textSecondary,
        marginTop: 4,
    },
    optionsContainer: {
        flexDirection: 'row',
        marginBottom: 8,
    },
    optionCard: {
        backgroundColor: KingdomColors.surface,
        borderRadius: 12,
        padding: 16,
        marginRight: 12,
        borderWidth: 1,
        borderColor: KingdomColors.border,
        alignItems: 'center',
        minWidth: 120,
    },
    optionCardSelected: {
        backgroundColor: KingdomColors.primary,
        borderColor: KingdomColors.primary,
    },
    premiumOption: {
        opacity: 0.6,
    },
    optionIcon: {
        fontSize: 24,
        marginBottom: 8,
    },
    optionTitle: {
        fontSize: 14,
        fontWeight: 'bold',
        color: KingdomColors.text,
        textAlign: 'center',
        marginBottom: 4,
    },
    optionTitleSelected: {
        color: KingdomColors.white,
    },
    optionDescription: {
        fontSize: 12,
        color: KingdomColors.textSecondary,
        textAlign: 'center',
    },
    optionDescriptionSelected: {
        color: KingdomColors.white,
        opacity: 0.9,
    },
    premiumBadge: {
        fontSize: 10,
        fontWeight: 'bold',
        color: KingdomColors.primary,
        marginTop: 4,
    },
    platformSection: {
        marginTop: 16,
    },
    platformsContainer: {
        flexDirection: 'row',
        marginTop: 8,
    },
    platformButton: {
        backgroundColor: KingdomColors.surface,
        borderRadius: 8,
        paddingHorizontal: 12,
        paddingVertical: 8,
        marginRight: 8,
        borderWidth: 1,
        borderColor: KingdomColors.border,
        alignItems: 'center',
    },
    platformButtonSelected: {
        backgroundColor: KingdomColors.primary,
        borderColor: KingdomColors.primary,
    },
    platformIcon: {
        fontSize: 20,
        marginBottom: 4,
    },
    platformLabel: {
        fontSize: 12,
        fontWeight: '600',
        color: KingdomColors.textSecondary,
        textAlign: 'center',
    },
    platformLabelSelected: {
        color: KingdomColors.white,
    },
    sessionsSection: {
        marginHorizontal: 20,
        marginBottom: 24,
    },
    sessionCard: {
        backgroundColor: KingdomColors.surface,
        borderRadius: 12,
        padding: 16,
        marginRight: 16,
        minWidth: 200,
        ...KingdomShadows.small,
    },
    sessionHeader: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'center',
        marginBottom: 8,
    },
    sessionIcon: {
        fontSize: 24,
    },
    sessionStatus: {
        fontSize: 12,
        color: KingdomColors.textSecondary,
        textTransform: 'capitalize',
    },
    sessionTitle: {
        fontSize: 16,
        fontWeight: 'bold',
        color: KingdomColors.text,
        marginBottom: 4,
    },
    sessionDuration: {
        fontSize: 14,
        color: KingdomColors.primary,
        fontFamily: 'monospace',
        marginBottom: 4,
    },
    sessionDate: {
        fontSize: 12,
        color: KingdomColors.textSecondary,
    },
    platformBadge: {
        fontSize: 10,
        fontWeight: 'bold',
        color: KingdomColors.primary,
        marginTop: 4,
        textTransform: 'uppercase',
    },
    tierSection: {
        marginHorizontal: 20,
        marginBottom: 24,
    },
    tierCard: {
        backgroundColor: KingdomColors.surface,
        borderRadius: 12,
        padding: 16,
        ...KingdomShadows.small,
    },
    tierTitle: {
        fontSize: 18,
        fontWeight: 'bold',
        color: KingdomColors.text,
        marginBottom: 8,
    },
    tierDescription: {
        fontSize: 14,
        color: KingdomColors.textSecondary,
        marginBottom: 8,
        lineHeight: 20,
    },
    creditsText: {
        fontSize: 14,
        fontWeight: '600',
        color: KingdomColors.primary,
    },
    processingOverlay: {
        position: 'absolute',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: 'rgba(0, 0, 0, 0.7)',
        justifyContent: 'center',
        alignItems: 'center',
    },
    processingText: {
        color: KingdomColors.white,
        fontSize: 16,
        marginTop: 16,
    },
}); 