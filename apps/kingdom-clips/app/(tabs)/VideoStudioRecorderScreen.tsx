import React, { useState, useRef, useEffect } from 'react';
import {
    View,
    Text,
    StyleSheet,
    ScrollView,
    TouchableOpacity,
    Alert,
    ActivityIndicator,
    Dimensions,
    Share,
    Platform,
    Switch,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { LinearGradient } from 'expo-linear-gradient';
import { Camera } from 'expo-camera';
import { Audio } from 'expo-av';
import { useFaithMode } from '../../../packages/hooks/useFaithMode';
import { Colors } from '@/constants/Colors';

const { width, height } = Dimensions.get('window');

interface RecordingSession {
    id: string;
    title: string;
    duration: number;
    participants: string[];
    recordingType: 'testimony' | 'teaching' | 'interview' | 'podcast' | 'live-stream';
    faithMode: boolean;
    createdAt: Date;
    status: 'recording' | 'paused' | 'completed' | 'processing' | 'live-streaming';
    liveStreamPlatform?: 'youtube' | 'facebook' | 'instagram' | 'tiktok' | 'linkedin';
    // New Riverside.fm features
    multitrackEnabled: boolean;
    progressiveUpload: boolean;
    aiSpeakerDetection: boolean;
    greenRoomEnabled: boolean;
    producerMode: boolean;
    teamRoles: TeamRole[];
    cloudStorage: CloudStorageInfo;
}

interface TeamRole {
    id: string;
    userId: string;
    role: 'host' | 'producer' | 'editor' | 'guest';
    permissions: string[];
    isActive: boolean;
}

interface CloudStorageInfo {
    sessionId: string;
    files: CloudFile[];
    totalSize: number;
    lastBackup: Date;
    encryptionEnabled: boolean;
}

interface CloudFile {
    id: string;
    name: string;
    type: 'audio' | 'video' | 'transcript' | 'summary';
    size: number;
    url: string;
    uploadedAt: Date;
    participantId?: string;
}

interface RecordingSettings {
    quality: 'hd' | '4k';
    audioQuality: 'standard' | 'high' | 'studio';
    recordingType: 'testimony' | 'teaching' | 'interview' | 'podcast' | 'live-stream';
    faithMode: boolean;
    enableTranscription: boolean;
    enableAutoEdit: boolean;
    enableFillerWordRemoval: boolean;
    enableAutoReelsCreation: boolean;
    enableLiveStreaming: boolean;
    liveStreamPlatform?: 'youtube' | 'facebook' | 'instagram' | 'tiktok' | 'linkedin';
    // New Riverside.fm settings
    enableMultitrack: boolean;
    enableProgressiveUpload: boolean;
    enableAISpeakerDetection: boolean;
    enableGreenRoom: boolean;
    enableProducerMode: boolean;
    enableTextBasedEditing: boolean;
    enableAutoLeveling: boolean;
    enableNoiseReduction: boolean;
    enableCustomBranding: boolean;
    enableLiveCallIn: boolean;
    enableTeamRoles: boolean;
    enableCloudStorage: boolean;
    enableEncryption: boolean;
    enableFailSafeBackups: boolean;
}

interface AutoGeneratedContent {
    id: string;
    type: 'reel' | 'story' | 'short';
    platform: 'instagram' | 'tiktok' | 'youtube' | 'facebook';
    duration: number;
    thumbnail: string;
    status: 'generating' | 'completed' | 'failed';
    createdAt: Date;
}

interface GreenRoomParticipant {
    id: string;
    name: string;
    audioTest: boolean;
    videoTest: boolean;
    background: string;
    isReady: boolean;
    joinTime?: Date;
}

interface TextBasedEdit {
    id: string;
    timestamp: number;
    originalText: string;
    editedText: string;
    action: 'delete' | 'replace' | 'add';
    participantId?: string;
}

export default function VideoStudioRecorderScreen() {
    const { faithMode, encouragementMode } = useFaithMode();

    const [hasPermission, setHasPermission] = useState<boolean | null>(null);
    const [isRecording, setIsRecording] = useState(false);
    const [isLiveStreaming, setIsLiveStreaming] = useState(false);
    const [recordingTime, setRecordingTime] = useState(0);
    const [currentSession, setCurrentSession] = useState<RecordingSession | null>(null);
    const [settings, setSettings] = useState<RecordingSettings>({
        quality: 'hd',
        audioQuality: 'high',
        recordingType: 'testimony',
        faithMode: faithMode,
        enableTranscription: true,
        enableAutoEdit: false,
        enableFillerWordRemoval: false,
        enableAutoReelsCreation: false,
        enableLiveStreaming: false,
        // New Riverside.fm settings
        enableMultitrack: false,
        enableProgressiveUpload: false,
        enableAISpeakerDetection: false,
        enableGreenRoom: false,
        enableProducerMode: false,
        enableTextBasedEditing: false,
        enableAutoLeveling: false,
        enableNoiseReduction: false,
        enableCustomBranding: false,
        enableLiveCallIn: false,
        enableTeamRoles: false,
        enableCloudStorage: false,
        enableEncryption: false,
        enableFailSafeBackups: false,
    });

    const [sessions, setSessions] = useState<RecordingSession[]>([]);
    const [autoGeneratedContent, setAutoGeneratedContent] = useState<AutoGeneratedContent[]>([]);
    const [isProcessing, setIsProcessing] = useState(false);
    const [isGeneratingContent, setIsGeneratingContent] = useState(false);
    const [inviteLink, setInviteLink] = useState<string | null>(null);

    const recordingInterval = useRef<NodeJS.Timeout | null>(null);

    // Mock tier system for Kingdom Clips
    const userTier = 'pro' as const; // Mock tier
    const canRecordVideo = true;
    const canLiveStream = false; // Mock - would be true for enterprise
    const canUseAI = true; // Mock - would check tier
    const remainingCredits = 60;
    const maxRecordingHours = 5; // Mock value

    const recordingTypeOptions = [
        { value: 'testimony', label: 'Testimony', icon: 'üôè', description: 'Share your faith story' },
        { value: 'teaching', label: 'Teaching', icon: 'üìö', description: 'Educational content' },
        { value: 'interview', label: 'Interview', icon: 'üé§', description: 'One-on-one conversation' },
        { value: 'podcast', label: 'Podcast', icon: 'üéôÔ∏è', description: 'Multi-guest podcast' },
        { value: 'live-stream', label: 'Live Stream', icon: 'üì°', description: 'Live streaming to social media', premium: true },
    ];

    const liveStreamPlatforms = [
        { value: 'youtube', label: 'YouTube Live', icon: 'üì∫', color: '#FF0000' },
        { value: 'facebook', label: 'Facebook Live', icon: 'üìò', color: '#1877F2' },
        { value: 'instagram', label: 'Instagram Live', icon: 'üì∑', color: '#E4405F' },
        { value: 'tiktok', label: 'TikTok Live', icon: 'üéµ', color: '#000000' },
        { value: 'linkedin', label: 'LinkedIn Live', icon: 'üíº', color: '#0A66C2' },
    ];

    const qualityOptions = [
        { value: 'hd', label: 'HD (1080p)', icon: 'üìπ' },
        { value: '4k', label: '4K Ultra HD', icon: 'üé¨' },
    ];

    const audioQualityOptions = [
        { value: 'standard', label: 'Standard', icon: 'üîä' },
        { value: 'high', label: 'High Quality', icon: 'üéµ' },
        { value: 'studio', label: 'Studio Quality', icon: 'üéõÔ∏è' },
    ];

    useEffect(() => {
        requestPermissions();
        return () => {
            if (recordingInterval.current) {
                clearInterval(recordingInterval.current);
            }
        };
    }, []);

    const requestPermissions = async () => {
        try {
            const { status: cameraStatus } = await Camera.requestCameraPermissionsAsync();
            const { status: audioStatus } = await Audio.requestPermissionsAsync();

            setHasPermission(cameraStatus === 'granted' && audioStatus === 'granted');
        } catch (error) {
            console.error('Permission request error:', error);
            setHasPermission(false);
        }
    };

    const startRecording = async () => {
        if (!hasPermission) {
            Alert.alert('Permissions Required', 'Camera and microphone permissions are required for recording.');
            return;
        }

        if (!canRecordVideo) {
            Alert.alert('Feature Unavailable', 'Video recording requires a Pro or Enterprise subscription.');
            return;
        }

        try {
            const sessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

            const newSession: RecordingSession = {
                id: sessionId,
                title: `${settings.recordingType.charAt(0).toUpperCase() + settings.recordingType.slice(1)} Recording`,
                duration: 0,
                participants: ['You'],
                recordingType: settings.recordingType,
                faithMode: settings.faithMode,
                createdAt: new Date(),
                status: settings.recordingType === 'live-stream' ? 'live-streaming' : 'recording',
                liveStreamPlatform: settings.liveStreamPlatform,
                // New Riverside.fm features
                multitrackEnabled: settings.enableMultitrack,
                progressiveUpload: settings.enableProgressiveUpload,
                aiSpeakerDetection: settings.enableAISpeakerDetection,
                greenRoomEnabled: settings.enableGreenRoom,
                producerMode: settings.enableProducerMode,
                teamRoles: [], // Mock data
                cloudStorage: { // Mock data
                    sessionId: sessionId,
                    files: [],
                    totalSize: 0,
                    lastBackup: new Date(),
                    encryptionEnabled: settings.enableEncryption,
                },
            };

            setCurrentSession(newSession);
            setIsRecording(true);
            setRecordingTime(0);

            // Start recording timer
            recordingInterval.current = setInterval(() => {
                setRecordingTime(prev => prev + 1);
            }, 1000);

            if (settings.recordingType === 'live-stream') {
                await startLiveStream(newSession);
            }

            Alert.alert(
                settings.recordingType === 'live-stream' ? 'Live Stream Started' : 'Recording Started',
                settings.recordingType === 'live-stream'
                    ? `Your live stream is now broadcasting to ${settings.liveStreamPlatform}.`
                    : 'Your video recording has begun. Tap the stop button when finished.'
            );

        } catch (error) {
            console.error('Recording start error:', error);
            Alert.alert('Recording Failed', 'Failed to start recording. Please try again.');
        }
    };

    const startLiveStream = async (session: RecordingSession) => {
        try {
            setIsLiveStreaming(true);
            // Simulate live streaming to social media platform
            console.log(`Starting live stream to ${session.liveStreamPlatform}`);

            // Here you would integrate with social media APIs
            // YouTube Live API, Facebook Live API, Instagram Live API, etc.

        } catch (error) {
            console.error('Live stream start error:', error);
            Alert.alert('Live Stream Failed', 'Failed to start live stream. Please try again.');
        }
    };

    const stopRecording = async () => {
        if (!currentSession) return;

        try {
            setIsRecording(false);
            setIsLiveStreaming(false);

            if (recordingInterval.current) {
                clearInterval(recordingInterval.current);
                recordingInterval.current = null;
            }

            // Update session with final duration
            const updatedSession: RecordingSession = {
                ...currentSession,
                duration: recordingTime,
                status: 'processing',
            };

            setSessions(prev => [updatedSession, ...prev]);
            setCurrentSession(null);
            setRecordingTime(0);

            // Process recording with AI features
            setIsProcessing(true);
            await processRecording(updatedSession);
            setIsProcessing(false);

            // Auto-generate content if enabled
            if (settings.enableAutoReelsCreation) {
                await generateAutoContent(updatedSession);
            }

            Alert.alert(
                'Recording Complete',
                'Your recording has been saved and is being processed with AI enhancements.',
                [
                    { text: 'View Auto-Generated Content', onPress: () => showAutoGeneratedContent() },
                    { text: 'OK' }
                ]
            );

        } catch (error) {
            console.error('Recording stop error:', error);
            Alert.alert('Recording Error', 'Failed to stop recording. Please try again.');
        }
    };

    const processRecording = async (session: RecordingSession) => {
        try {
            // AI Processing Pipeline
            const processingSteps = [];

            if (settings.enableTranscription) {
                processingSteps.push('Transcribing audio...');
            }

            if (settings.enableFillerWordRemoval) {
                processingSteps.push('Removing filler words...');
            }

            if (settings.enableAutoEdit) {
                processingSteps.push('Auto-editing content...');
            }

            // Simulate AI processing
            for (const step of processingSteps) {
                console.log(step);
                await new Promise(resolve => setTimeout(resolve, 2000));
            }

            console.log('Recording processed with AI enhancements:', session.id);
        } catch (error) {
            console.error('Recording processing error:', error);
        }
    };

    const generateAutoContent = async (session: RecordingSession) => {
        try {
            setIsGeneratingContent(true);

            const platforms = ['instagram', 'tiktok', 'youtube', 'facebook'];
            const contentTypes = ['reel', 'story', 'short'];

            const newContent: AutoGeneratedContent[] = [];

            for (const platform of platforms) {
                for (const contentType of contentTypes) {
                    const content: AutoGeneratedContent = {
                        id: `content_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                        type: contentType as any,
                        platform: platform as any,
                        duration: Math.floor(Math.random() * 60) + 15, // 15-75 seconds
                        thumbnail: `https://picsum.photos/300/400?random=${Math.random()}`,
                        status: 'generating',
                        createdAt: new Date(),
                    };

                    newContent.push(content);
                }
            }

            setAutoGeneratedContent(prev => [...newContent, ...prev]);

            // Simulate AI content generation
            await new Promise(resolve => setTimeout(resolve, 3000));

            // Update status to completed
            setAutoGeneratedContent(prev =>
                prev.map(content => ({ ...content, status: 'completed' as any }))
            );

            setIsGeneratingContent(false);

        } catch (error) {
            console.error('Auto content generation error:', error);
            setIsGeneratingContent(false);
        }
    };

    const showAutoGeneratedContent = () => {
        Alert.alert(
            'Auto-Generated Content',
            `Generated ${autoGeneratedContent.length} pieces of content from your video:\n\n` +
            autoGeneratedContent.map(content =>
                `${content.platform} ${content.type} (${content.duration}s)`
            ).join('\n'),
            [
                { text: 'View All', onPress: () => {/* Navigate to content library */ } },
                { text: 'OK' }
            ]
        );
    };

    const generateInviteLink = async () => {
        if (!currentSession) return;

        try {
            const link = `https://kingdomclips.app/join-recording/${currentSession.id}?type=${settings.recordingType}&max=5`;
            setInviteLink(link);

            Alert.alert(
                'Invite Link Generated',
                'Share this link with your guests to join the recording session.',
                [
                    { text: 'Copy Link', onPress: () => {/* Copy to clipboard */ } },
                    { text: 'Share', onPress: () => shareInviteLink(link) },
                    { text: 'OK' },
                ]
            );
        } catch (error) {
            Alert.alert('Error', 'Failed to generate invite link. Please try again.');
        }
    };

    const shareInviteLink = async (link: string) => {
        try {
            await Share.share({
                url: link,
                message: `Join my ${settings.recordingType} recording session: ${link}`,
            });
        } catch (error) {
            Alert.alert('Error', 'Failed to share invite link.');
        }
    };

    const formatTime = (seconds: number): string => {
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        const secs = seconds % 60;
        return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    };

    const renderRecordingControls = () => (
        <View style={styles.recordingSection}>
            <View style={styles.recordingInfo}>
                <Text style={styles.recordingTitle}>
                    {currentSession?.title || 'Ready to Record'}
                </Text>
                <Text style={styles.recordingTime}>
                    {formatTime(recordingTime)}
                </Text>
                {isLiveStreaming && (
                    <View style={styles.liveIndicator}>
                        <Text style={styles.liveText}>üî¥ LIVE</Text>
                        <Text style={styles.platformText}>
                            Streaming to {settings.liveStreamPlatform}
                        </Text>
                    </View>
                )}
            </View>

            <View style={styles.controlButtons}>
                {!isRecording ? (
                    <TouchableOpacity
                        style={[
                            styles.recordButton,
                            !canRecordVideo && styles.disabledButton
                        ]}
                        onPress={startRecording}
                        disabled={!canRecordVideo}
                    >
                        <Text style={styles.recordButtonText}>
                            {settings.recordingType === 'live-stream' ? 'üî¥ Go Live' : 'üéôÔ∏è Start Recording'}
                        </Text>
                    </TouchableOpacity>
                ) : (
                    <TouchableOpacity
                        style={styles.stopButton}
                        onPress={stopRecording}
                    >
                        <Text style={styles.stopButtonText}>‚èπÔ∏è Stop</Text>
                    </TouchableOpacity>
                )}

                {isRecording && (
                    <TouchableOpacity
                        style={styles.inviteButton}
                        onPress={generateInviteLink}
                    >
                        <Text style={styles.inviteButtonText}>üë• Invite Guests</Text>
                    </TouchableOpacity>
                )}
            </View>
        </View>
    );

    const renderAdvancedSettings = () => (
        <View style={styles.settingsSection}>
            <Text style={styles.sectionTitle}>Advanced AI Features</Text>

            {/* AI Filler Word Removal */}
            <View style={styles.settingRow}>
                <View style={styles.settingInfo}>
                    <Text style={styles.settingLabel}>AI Filler Word Removal</Text>
                    <Text style={styles.settingDescription}>
                        Automatically remove "um", "uh", "like", "you know" from audio
                    </Text>
                </View>
                <Switch
                    value={settings.enableFillerWordRemoval}
                    onValueChange={(value) => setSettings(prev => ({ ...prev, enableFillerWordRemoval: value }))}
                    disabled={!canUseAI}
                    trackColor={{ false: '#E5E5E5', true: Colors.light.accent }}
                    thumbColor={settings.enableFillerWordRemoval ? '#FFFFFF' : '#666666'}
                />
            </View>

            {/* Auto Edit */}
            <View style={styles.settingRow}>
                <View style={styles.settingInfo}>
                    <Text style={styles.settingLabel}>AI Auto Edit</Text>
                    <Text style={styles.settingDescription}>
                        Automatically edit out silence and improve pacing
                    </Text>
                </View>
                <Switch
                    value={settings.enableAutoEdit}
                    onValueChange={(value) => setSettings(prev => ({ ...prev, enableAutoEdit: value }))}
                    disabled={!canUseAI}
                    trackColor={{ false: Colors.border, true: Colors.primary }}
                    thumbColor={settings.enableAutoEdit ? Colors.white : Colors.textSecondary}
                />
            </View>

            {/* Auto Reels Creation */}
            <View style={styles.settingRow}>
                <View style={styles.settingInfo}>
                    <Text style={styles.settingLabel}>Auto-Create Reels/Stories</Text>
                    <Text style={styles.settingDescription}>
                        AI automatically creates reels, stories, and shorts from your video
                    </Text>
                </View>
                <Switch
                    value={settings.enableAutoReelsCreation}
                    onValueChange={(value) => setSettings(prev => ({ ...prev, enableAutoReelsCreation: value }))}
                    disabled={!canUseAI}
                    trackColor={{ false: Colors.border, true: Colors.primary }}
                    thumbColor={settings.enableAutoReelsCreation ? Colors.white : Colors.textSecondary}
                />
            </View>

            {/* Live Streaming */}
            <View style={styles.settingRow}>
                <View style={styles.settingInfo}>
                    <Text style={styles.settingLabel}>Live Streaming</Text>
                    <Text style={styles.settingDescription}>
                        Stream directly to social media platforms
                    </Text>
                </View>
                <Switch
                    value={settings.enableLiveStreaming}
                    onValueChange={(value) => setSettings(prev => ({ ...prev, enableLiveStreaming: value }))}
                    disabled={!canLiveStream}
                    trackColor={{ false: Colors.border, true: Colors.primary }}
                    thumbColor={settings.enableLiveStreaming ? Colors.white : Colors.textSecondary}
                />
            </View>

            {/* Live Stream Platform Selection */}
            {settings.enableLiveStreaming && (
                <View style={styles.platformSection}>
                    <Text style={styles.settingLabel}>Live Stream Platform</Text>
                    <ScrollView horizontal showsHorizontalScrollIndicator={false} style={styles.platformsContainer}>
                        {liveStreamPlatforms.map((platform) => (
                            <TouchableOpacity
                                key={platform.value}
                                style={[
                                    styles.platformButton,
                                    settings.liveStreamPlatform === platform.value && styles.platformButtonSelected
                                ]}
                                onPress={() => setSettings(prev => ({ ...prev, liveStreamPlatform: platform.value as any }))}
                            >
                                <Text style={styles.platformIcon}>{platform.icon}</Text>
                                <Text style={[
                                    styles.platformLabel,
                                    settings.liveStreamPlatform === platform.value && styles.platformLabelSelected
                                ]}>
                                    {platform.label}
                                </Text>
                            </TouchableOpacity>
                        ))}
                    </ScrollView>
                </View>
            )}
        </View>
    );

    const renderSettings = () => (
        <View style={styles.settingsSection}>
            <Text style={styles.sectionTitle}>Recording Settings</Text>

            {/* Recording Type Selection */}
            <Text style={styles.settingLabel}>Recording Type</Text>
            <ScrollView horizontal showsHorizontalScrollIndicator={false} style={styles.optionsContainer}>
                {recordingTypeOptions.map((option) => (
                    <TouchableOpacity
                        key={option.value}
                        style={[
                            styles.optionCard,
                            settings.recordingType === option.value && styles.optionCardSelected,
                            option.premium && !canLiveStream && styles.premiumOption
                        ]}
                        onPress={() => {
                            if (option.premium && !canLiveStream) {
                                Alert.alert('Premium Feature', 'Live streaming requires an Enterprise subscription.');
                                return;
                            }
                            setSettings(prev => ({ ...prev, recordingType: option.value as any }));
                        }}
                    >
                        <Text style={styles.optionIcon}>{option.icon}</Text>
                        <Text style={[
                            styles.optionTitle,
                            settings.recordingType === option.value && styles.optionTitleSelected
                        ]}>
                            {option.label}
                        </Text>
                        <Text style={[
                            styles.optionDescription,
                            settings.recordingType === option.value && styles.optionDescriptionSelected
                        ]}>
                            {option.description}
                        </Text>
                        {option.premium && (
                            <Text style={styles.premiumBadge}>PRO</Text>
                        )}
                    </TouchableOpacity>
                ))}
            </ScrollView>

            {/* Video Quality */}
            <Text style={styles.settingLabel}>Video Quality</Text>
            <ScrollView horizontal showsHorizontalScrollIndicator={false} style={styles.optionsContainer}>
                {qualityOptions.map((option) => (
                    <TouchableOpacity
                        key={option.value}
                        style={[
                            styles.optionCard,
                            settings.quality === option.value && styles.optionCardSelected
                        ]}
                        onPress={() => setSettings(prev => ({ ...prev, quality: option.value as any }))}
                    >
                        <Text style={styles.optionIcon}>{option.icon}</Text>
                        <Text style={[
                            styles.optionTitle,
                            settings.quality === option.value && styles.optionTitleSelected
                        ]}>
                            {option.label}
                        </Text>
                    </TouchableOpacity>
                ))}
            </ScrollView>

            {/* Audio Quality */}
            <Text style={styles.settingLabel}>Audio Quality</Text>
            <ScrollView horizontal showsHorizontalScrollIndicator={false} style={styles.optionsContainer}>
                {audioQualityOptions.map((option) => (
                    <TouchableOpacity
                        key={option.value}
                        style={[
                            styles.optionCard,
                            settings.audioQuality === option.value && styles.optionCardSelected
                        ]}
                        onPress={() => setSettings(prev => ({ ...prev, audioQuality: option.value as any }))}
                    >
                        <Text style={styles.optionIcon}>{option.icon}</Text>
                        <Text style={[
                            styles.optionTitle,
                            settings.audioQuality === option.value && styles.optionTitleSelected
                        ]}>
                            {option.label}
                        </Text>
                    </TouchableOpacity>
                ))}
            </ScrollView>
        </View>
    );

    const renderRecentSessions = () => (
        <View style={styles.sessionsSection}>
            <Text style={styles.sectionTitle}>Recent Recordings</Text>
            <ScrollView horizontal showsHorizontalScrollIndicator={false}>
                {sessions.map((session) => (
                    <TouchableOpacity
                        key={session.id}
                        style={styles.sessionCard}
                        onPress={() => {/* Navigate to session details */ }}
                    >
                        <View style={styles.sessionHeader}>
                            <Text style={styles.sessionIcon}>
                                {session.recordingType === 'podcast' ? 'üéôÔ∏è' :
                                    session.recordingType === 'interview' ? 'üé§' :
                                        session.recordingType === 'teaching' ? 'üìö' :
                                            session.recordingType === 'live-stream' ? 'üì°' : 'üôè'}
                            </Text>
                            <Text style={styles.sessionStatus}>{session.status}</Text>
                        </View>
                        <Text style={styles.sessionTitle}>{session.title}</Text>
                        <Text style={styles.sessionDuration}>{formatTime(session.duration)}</Text>
                        <Text style={styles.sessionDate}>
                            {session.createdAt.toLocaleDateString()}
                        </Text>
                        {session.liveStreamPlatform && (
                            <Text style={styles.platformBadge}>
                                {session.liveStreamPlatform}
                            </Text>
                        )}
                    </TouchableOpacity>
                ))}
            </ScrollView>
        </View>
    );

    const renderTierInfo = () => (
        <View style={styles.tierSection}>
            <Text style={styles.sectionTitle}>Subscription Status</Text>
            <View style={styles.tierCard}>
                <Text style={styles.tierTitle}>Current Tier: {userTier.toUpperCase()}</Text>
                <Text style={styles.tierDescription}>
                    {userTier === 'enterprise' ? 'Unlimited features and live streaming' :
                        userTier === 'pro' ? 'Advanced AI features and longer recordings' :
                            'Basic recording features'}
                </Text>
                <Text style={styles.creditsText}>
                    Remaining Credits: {remainingCredits} / {maxRecordingHours * 60} minutes
                </Text>
            </View>
        </View>
    );

    if (hasPermission === null) {
        return (
            <SafeAreaView style={styles.container}>
                <View style={styles.loadingContainer}>
                    <ActivityIndicator size="large" color={Colors.primary} />
                    <Text style={styles.loadingText}>Requesting permissions...</Text>
                </View>
            </SafeAreaView>
        );
    }

    if (hasPermission === false) {
        return (
            <SafeAreaView style={styles.container}>
                <View style={styles.permissionContainer}>
                    <Text style={styles.permissionTitle}>Permissions Required</Text>
                    <Text style={styles.permissionText}>
                        Camera and microphone permissions are required for video recording.
                    </Text>
                    <TouchableOpacity style={styles.permissionButton} onPress={requestPermissions}>
                        <Text style={styles.permissionButtonText}>Grant Permissions</Text>
                    </TouchableOpacity>
                </View>
            </SafeAreaView>
        );
    }

    return (
        <SafeAreaView style={styles.container}>
            <ScrollView style={styles.scrollView} showsVerticalScrollIndicator={false}>
                <View style={styles.header}>
                    <Text style={styles.title}>Video Studio Recorder</Text>
                    <Text style={styles.subtitle}>
                        Professional video recording with AI enhancements and live streaming
                    </Text>
                </View>

                {renderRecordingControls()}
                {renderSettings()}
                {renderAdvancedSettings()}
                {renderRecentSessions()}
                {renderTierInfo()}
            </ScrollView>

            {isProcessing && (
                <View style={styles.processingOverlay}>
                    <ActivityIndicator size="large" color={Colors.white} />
                    <Text style={styles.processingText}>Processing with AI...</Text>
                </View>
            )}

            {isGeneratingContent && (
                <View style={styles.processingOverlay}>
                    <ActivityIndicator size="large" color={Colors.white} />
                    <Text style={styles.processingText}>Creating reels and stories...</Text>
                </View>
            )}
        </SafeAreaView>
    );
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: Colors.background,
    },
    scrollView: {
        flex: 1,
    },
    header: {
        padding: 20,
        alignItems: 'center',
    },
    title: {
        fontSize: 28,
        fontWeight: 'bold',
        color: Colors.text,
        marginBottom: 8,
    },
    subtitle: {
        fontSize: 16,
        color: Colors.textSecondary,
        textAlign: 'center',
        lineHeight: 22,
    },
    loadingContainer: {
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center',
    },
    loadingText: {
        marginTop: 16,
        fontSize: 16,
        color: Colors.textSecondary,
    },
    permissionContainer: {
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center',
        padding: 20,
    },
    permissionTitle: {
        fontSize: 24,
        fontWeight: 'bold',
        color: Colors.text,
        marginBottom: 16,
    },
    permissionText: {
        fontSize: 16,
        color: Colors.textSecondary,
        textAlign: 'center',
        marginBottom: 24,
        lineHeight: 22,
    },
    permissionButton: {
        backgroundColor: Colors.primary,
        borderRadius: 12,
        paddingVertical: 16,
        paddingHorizontal: 32,
    },
    permissionButtonText: {
        fontSize: 18,
        fontWeight: 'bold',
        color: Colors.white,
    },
    recordingSection: {
        marginHorizontal: 20,
        marginBottom: 24,
        backgroundColor: Colors.surface,
        borderRadius: 16,
        padding: 20,
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.1,
        shadowRadius: 4,
        elevation: 3,
    },
    recordingInfo: {
        alignItems: 'center',
        marginBottom: 20,
    },
    recordingTitle: {
        fontSize: 20,
        fontWeight: 'bold',
        color: Colors.text,
        marginBottom: 8,
    },
    recordingTime: {
        fontSize: 32,
        fontWeight: 'bold',
        color: Colors.primary,
        fontFamily: 'monospace',
    },
    liveIndicator: {
        alignItems: 'center',
        marginTop: 8,
    },
    liveText: {
        fontSize: 16,
        fontWeight: 'bold',
        color: Colors.error,
    },
    platformText: {
        fontSize: 14,
        color: Colors.textSecondary,
    },
    controlButtons: {
        flexDirection: 'row',
        justifyContent: 'space-around',
    },
    recordButton: {
        backgroundColor: Colors.success,
        borderRadius: 12,
        paddingVertical: 16,
        paddingHorizontal: 24,
        flex: 1,
        marginHorizontal: 8,
        alignItems: 'center',
    },
    disabledButton: {
        backgroundColor: Colors.textSecondary,
    },
    recordButtonText: {
        fontSize: 16,
        fontWeight: 'bold',
        color: Colors.white,
    },
    stopButton: {
        backgroundColor: Colors.error,
        borderRadius: 12,
        paddingVertical: 16,
        paddingHorizontal: 24,
        flex: 1,
        marginHorizontal: 8,
        alignItems: 'center',
    },
    stopButtonText: {
        fontSize: 16,
        fontWeight: 'bold',
        color: Colors.white,
    },
    inviteButton: {
        backgroundColor: Colors.primary,
        borderRadius: 12,
        paddingVertical: 12,
        paddingHorizontal: 16,
        marginTop: 12,
        alignItems: 'center',
    },
    inviteButtonText: {
        fontSize: 14,
        fontWeight: '600',
        color: Colors.white,
    },
    settingsSection: {
        marginHorizontal: 20,
        marginBottom: 24,
    },
    sectionTitle: {
        fontSize: 20,
        fontWeight: 'bold',
        color: Colors.text,
        marginBottom: 16,
    },
    settingLabel: {
        fontSize: 16,
        fontWeight: '600',
        color: Colors.text,
        marginBottom: 12,
        marginTop: 16,
    },
    settingRow: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'center',
        paddingVertical: 12,
        borderBottomWidth: 1,
        borderBottomColor: Colors.border,
    },
    settingInfo: {
        flex: 1,
        marginRight: 16,
    },
    settingDescription: {
        fontSize: 14,
        color: Colors.textSecondary,
        marginTop: 4,
    },
    optionsContainer: {
        flexDirection: 'row',
        marginBottom: 8,
    },
    optionCard: {
        backgroundColor: Colors.surface,
        borderRadius: 12,
        padding: 16,
        marginRight: 12,
        borderWidth: 1,
        borderColor: Colors.border,
        alignItems: 'center',
        minWidth: 120,
    },
    optionCardSelected: {
        backgroundColor: Colors.primary,
        borderColor: Colors.primary,
    },
    premiumOption: {
        opacity: 0.6,
    },
    optionIcon: {
        fontSize: 24,
        marginBottom: 8,
    },
    optionTitle: {
        fontSize: 14,
        fontWeight: 'bold',
        color: Colors.text,
        textAlign: 'center',
        marginBottom: 4,
    },
    optionTitleSelected: {
        color: Colors.white,
    },
    optionDescription: {
        fontSize: 12,
        color: Colors.textSecondary,
        textAlign: 'center',
    },
    optionDescriptionSelected: {
        color: Colors.white,
        opacity: 0.9,
    },
    premiumBadge: {
        fontSize: 10,
        fontWeight: 'bold',
        color: Colors.primary,
        marginTop: 4,
    },
    platformSection: {
        marginTop: 16,
    },
    platformsContainer: {
        flexDirection: 'row',
        marginTop: 8,
    },
    platformButton: {
        backgroundColor: Colors.surface,
        borderRadius: 8,
        paddingHorizontal: 12,
        paddingVertical: 8,
        marginRight: 8,
        borderWidth: 1,
        borderColor: Colors.border,
        alignItems: 'center',
    },
    platformButtonSelected: {
        backgroundColor: Colors.primary,
        borderColor: Colors.primary,
    },
    platformIcon: {
        fontSize: 20,
        marginBottom: 4,
    },
    platformLabel: {
        fontSize: 12,
        fontWeight: '600',
        color: Colors.textSecondary,
        textAlign: 'center',
    },
    platformLabelSelected: {
        color: Colors.white,
    },
    sessionsSection: {
        marginHorizontal: 20,
        marginBottom: 24,
    },
    sessionCard: {
        backgroundColor: Colors.surface,
        borderRadius: 12,
        padding: 16,
        marginRight: 16,
        minWidth: 200,
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 1 },
        shadowOpacity: 0.1,
        shadowRadius: 2,
        elevation: 2,
    },
    sessionHeader: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'center',
        marginBottom: 8,
    },
    sessionIcon: {
        fontSize: 24,
    },
    sessionStatus: {
        fontSize: 12,
        color: Colors.textSecondary,
        textTransform: 'capitalize',
    },
    sessionTitle: {
        fontSize: 16,
        fontWeight: 'bold',
        color: Colors.text,
        marginBottom: 4,
    },
    sessionDuration: {
        fontSize: 14,
        color: Colors.primary,
        fontFamily: 'monospace',
        marginBottom: 4,
    },
    sessionDate: {
        fontSize: 12,
        color: Colors.textSecondary,
    },
    platformBadge: {
        fontSize: 10,
        fontWeight: 'bold',
        color: Colors.primary,
        marginTop: 4,
        textTransform: 'uppercase',
    },
    tierSection: {
        marginHorizontal: 20,
        marginBottom: 24,
    },
    tierCard: {
        backgroundColor: Colors.surface,
        borderRadius: 12,
        padding: 16,
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 1 },
        shadowOpacity: 0.1,
        shadowRadius: 2,
        elevation: 2,
    },
    tierTitle: {
        fontSize: 18,
        fontWeight: 'bold',
        color: Colors.text,
        marginBottom: 8,
    },
    tierDescription: {
        fontSize: 14,
        color: Colors.textSecondary,
        marginBottom: 8,
        lineHeight: 20,
    },
    creditsText: {
        fontSize: 14,
        fontWeight: '600',
        color: Colors.primary,
    },
    processingOverlay: {
        position: 'absolute',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: 'rgba(0, 0, 0, 0.7)',
        justifyContent: 'center',
        alignItems: 'center',
    },
    processingText: {
        color: Colors.white,
        fontSize: 16,
        marginTop: 16,
    },
}); 