import React, { useState, useRef, useEffect } from 'react';
import {
    View,
    Text,
    StyleSheet,
    ScrollView,
    TouchableOpacity,
    Alert,
    ActivityIndicator,
    Dimensions,
    Share,
    Platform,
    Switch,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Camera } from 'expo-camera';
import { Audio } from 'expo-av';
import { Colors } from '@/constants/Colors';

const { width, height } = Dimensions.get('window');

interface RecordingSession {
    id: string;
    title: string;
    duration: number;
    participants: string[];
    recordingType: 'photography' | 'tutorial' | 'behind-scenes' | 'client-session' | 'live-stream';
    faithMode: boolean;
    createdAt: Date;
    status: 'recording' | 'paused' | 'completed' | 'processing' | 'live-streaming';
    liveStreamPlatform?: 'youtube' | 'facebook' | 'instagram' | 'tiktok' | 'linkedin';
    // Riverside.fm features
    multitrackEnabled: boolean;
    progressiveUpload: boolean;
    aiSpeakerDetection: boolean;
    greenRoomEnabled: boolean;
    producerMode: boolean;
    teamRoles: TeamRole[];
    cloudStorage: CloudStorageInfo;
}

interface TeamRole {
    id: string;
    userId: string;
    role: 'host' | 'producer' | 'editor' | 'guest';
    permissions: string[];
    isActive: boolean;
}

interface CloudStorageInfo {
    sessionId: string;
    files: CloudFile[];
    totalSize: number;
    lastBackup: Date;
    encryptionEnabled: boolean;
}

interface CloudFile {
    id: string;
    name: string;
    type: 'audio' | 'video' | 'transcript' | 'summary';
    size: number;
    url: string;
    uploadedAt: Date;
    participantId?: string;
}

interface RecordingSettings {
    quality: 'hd' | '4k';
    audioQuality: 'standard' | 'high' | 'studio';
    recordingType: 'photography' | 'tutorial' | 'behind-scenes' | 'client-session' | 'live-stream';
    faithMode: boolean;
    enableTranscription: boolean;
    enableAutoEdit: boolean;
    enableFillerWordRemoval: boolean;
    enableAutoReelsCreation: boolean;
    enableLiveStreaming: boolean;
    liveStreamPlatform?: 'youtube' | 'facebook' | 'instagram' | 'tiktok' | 'linkedin';
    // Riverside.fm settings
    enableMultitrack: boolean;
    enableProgressiveUpload: boolean;
    enableAISpeakerDetection: boolean;
    enableGreenRoom: boolean;
    enableProducerMode: boolean;
    enableTextBasedEditing: boolean;
    enableAutoLeveling: boolean;
    enableNoiseReduction: boolean;
    enableCustomBranding: boolean;
    enableLiveCallIn: boolean;
    enableTeamRoles: boolean;
    enableCloudStorage: boolean;
    enableEncryption: boolean;
    enableFailSafeBackups: boolean;
}

interface AutoGeneratedContent {
    id: string;
    type: 'reel' | 'story' | 'short';
    platform: 'instagram' | 'tiktok' | 'youtube' | 'facebook';
    duration: number;
    thumbnail: string;
    status: 'generating' | 'completed' | 'failed';
    createdAt: Date;
}

interface GreenRoomParticipant {
    id: string;
    name: string;
    audioTest: boolean;
    videoTest: boolean;
    background: string;
    isReady: boolean;
    joinTime?: Date;
}

interface TextBasedEdit {
    id: string;
    timestamp: number;
    originalText: string;
    editedText: string;
    action: 'delete' | 'replace' | 'add';
    participantId?: string;
}

export default function VideoStudioRecorderScreen() {
    const [hasPermission, setHasPermission] = useState<boolean | null>(null);
    const [isRecording, setIsRecording] = useState(false);
    const [isLiveStreaming, setIsLiveStreaming] = useState(false);
    const [recordingTime, setRecordingTime] = useState(0);
    const [currentSession, setCurrentSession] = useState<RecordingSession | null>(null);
    const [settings, setSettings] = useState<RecordingSettings>({
        quality: '4k', // High quality for visual content
        audioQuality: 'high',
        recordingType: 'photography',
        faithMode: true,
        enableTranscription: true,
        enableAutoEdit: false,
        enableFillerWordRemoval: false,
        enableAutoReelsCreation: false,
        enableLiveStreaming: false,
        // Riverside.fm settings
        enableMultitrack: true,
        enableProgressiveUpload: true,
        enableAISpeakerDetection: true,
        enableGreenRoom: true,
        enableProducerMode: false,
        enableTextBasedEditing: true,
        enableAutoLeveling: true,
        enableNoiseReduction: true,
        enableCustomBranding: true, // Important for visual content
        enableLiveCallIn: false,
        enableTeamRoles: false,
        enableCloudStorage: true,
        enableEncryption: true,
        enableFailSafeBackups: true,
    });

    const [sessions, setSessions] = useState<RecordingSession[]>([]);
    const [autoGeneratedContent, setAutoGeneratedContent] = useState<AutoGeneratedContent[]>([]);
    const [isProcessing, setIsProcessing] = useState(false);
    const [isGeneratingContent, setIsGeneratingContent] = useState(false);
    const [inviteLink, setInviteLink] = useState<string | null>(null);
    // Riverside.fm state
    const [greenRoomParticipants, setGreenRoomParticipants] = useState<GreenRoomParticipant[]>([]);
    const [textBasedEdits, setTextBasedEdits] = useState<TextBasedEdit[]>([]);
    const [isInGreenRoom, setIsInGreenRoom] = useState(false);
    const [isProducerMode, setIsProducerMode] = useState(false);
    const [teamRoles, setTeamRoles] = useState<TeamRole[]>([]);
    const [cloudFiles, setCloudFiles] = useState<CloudFile[]>([]);
    const [isUploading, setIsUploading] = useState(false);
    const [uploadProgress, setUploadProgress] = useState(0);

    const recordingInterval = useRef<NodeJS.Timeout | null>(null);

    // Mock tier system for Kingdom Lens
    const userTier = 'pro' as const;
    const canRecordVideo = true;
    const canLiveStream = false;
    const canUseAI = true;
    const remainingCredits = 60;
    const maxRecordingHours = 5;

    const recordingTypeOptions = [
        { value: 'photography', label: 'Photography', icon: '📸', description: 'Photography session recording' },
        { value: 'tutorial', label: 'Tutorial', icon: '🎓', description: 'Photography tutorial content' },
        { value: 'behind-scenes', label: 'Behind Scenes', icon: '🎬', description: 'Behind the scenes content' },
        { value: 'client-session', label: 'Client Session', icon: '👥', description: 'Client photography session' },
        { value: 'live-stream', label: 'Live Stream', icon: '📡', description: 'Live streaming to social media', premium: true },
    ];

    const liveStreamPlatforms = [
        { value: 'youtube', label: 'YouTube Live', icon: '📺', color: '#FF0000' },
        { value: 'facebook', label: 'Facebook Live', icon: '📘', color: '#1877F2' },
        { value: 'instagram', label: 'Instagram Live', icon: '📷', color: '#E4405F' },
        { value: 'tiktok', label: 'TikTok Live', icon: '🎵', color: '#000000' },
        { value: 'linkedin', label: 'LinkedIn Live', icon: '💼', color: '#0A66C2' },
    ];

    const qualityOptions = [
        { value: 'hd', label: 'HD (1080p)', icon: '📹' },
        { value: '4k', label: '4K Ultra HD', icon: '🎬' },
    ];

    const audioQualityOptions = [
        { value: 'standard', label: 'Standard', icon: '🔊' },
        { value: 'high', label: 'High Quality', icon: '🎵' },
        { value: 'studio', label: 'Studio Quality', icon: '🎛️' },
    ];

    useEffect(() => {
        requestPermissions();
        return () => {
            if (recordingInterval.current) {
                clearInterval(recordingInterval.current);
            }
        };
    }, []);

    const requestPermissions = async () => {
        try {
            const { status: cameraStatus } = await Camera.requestCameraPermissionsAsync();
            const { status: audioStatus } = await Audio.requestPermissionsAsync();

            setHasPermission(cameraStatus === 'granted' && audioStatus === 'granted');
        } catch (error) {
            console.error('Permission request error:', error);
            setHasPermission(false);
        }
    };

    const startRecording = async () => {
        if (!hasPermission) {
            Alert.alert('Permissions Required', 'Camera and microphone permissions are required for recording.');
            return;
        }

        if (!canRecordVideo) {
            Alert.alert('Feature Unavailable', 'Video recording requires a Pro or Enterprise subscription.');
            return;
        }

        try {
            const sessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

            const newSession: RecordingSession = {
                id: sessionId,
                title: `${settings.recordingType.charAt(0).toUpperCase() + settings.recordingType.slice(1)} Recording`,
                duration: 0,
                participants: ['You'],
                recordingType: settings.recordingType,
                faithMode: settings.faithMode,
                createdAt: new Date(),
                status: settings.recordingType === 'live-stream' ? 'live-streaming' : 'recording',
                liveStreamPlatform: settings.liveStreamPlatform,
                // Riverside.fm features
                multitrackEnabled: settings.enableMultitrack,
                progressiveUpload: settings.enableProgressiveUpload,
                aiSpeakerDetection: settings.enableAISpeakerDetection,
                greenRoomEnabled: settings.enableGreenRoom,
                producerMode: settings.enableProducerMode,
                teamRoles: [],
                cloudStorage: {
                    sessionId: sessionId,
                    files: [],
                    totalSize: 0,
                    lastBackup: new Date(),
                    encryptionEnabled: settings.enableEncryption,
                },
            };

            setCurrentSession(newSession);
            setIsRecording(true);
            setRecordingTime(0);

            // Start recording timer
            recordingInterval.current = setInterval(() => {
                setRecordingTime(prev => prev + 1);
            }, 1000);

            if (settings.recordingType === 'live-stream') {
                await startLiveStream(newSession);
            }

            Alert.alert(
                settings.recordingType === 'live-stream' ? 'Live Stream Started' : 'Recording Started',
                settings.recordingType === 'live-stream'
                    ? `Your live stream is now broadcasting to ${settings.liveStreamPlatform}.`
                    : 'Your photography session recording has begun. Tap the stop button when finished.'
            );

        } catch (error) {
            console.error('Recording start error:', error);
            Alert.alert('Recording Failed', 'Failed to start recording. Please try again.');
        }
    };

    const startLiveStream = async (session: RecordingSession) => {
        try {
            setIsLiveStreaming(true);
            console.log(`Starting live stream to ${session.liveStreamPlatform}`);
        } catch (error) {
            console.error('Live stream start error:', error);
            Alert.alert('Live Stream Failed', 'Failed to start live stream. Please try again.');
        }
    };

    const stopRecording = async () => {
        if (!currentSession) return;

        try {
            setIsRecording(false);
            setIsLiveStreaming(false);

            if (recordingInterval.current) {
                clearInterval(recordingInterval.current);
                recordingInterval.current = null;
            }

            const updatedSession: RecordingSession = {
                ...currentSession,
                duration: recordingTime,
                status: 'processing',
            };

            setSessions(prev => [updatedSession, ...prev]);
            setCurrentSession(null);
            setRecordingTime(0);

            setIsProcessing(true);
            await processRecording(updatedSession);
            setIsProcessing(false);

            if (settings.enableAutoReelsCreation) {
                await generateAutoContent(updatedSession);
            }

            Alert.alert(
                'Recording Complete',
                'Your photography session has been saved and is being processed with AI enhancements.',
                [
                    { text: 'View Auto-Generated Content', onPress: () => showAutoGeneratedContent() },
                    { text: 'OK' }
                ]
            );

        } catch (error) {
            console.error('Recording stop error:', error);
            Alert.alert('Recording Error', 'Failed to stop recording. Please try again.');
        }
    };

    const processRecording = async (session: RecordingSession) => {
        try {
            const processingSteps = [];

            if (settings.enableTranscription) {
                processingSteps.push('Transcribing audio...');
            }

            if (settings.enableFillerWordRemoval) {
                processingSteps.push('Removing filler words...');
            }

            if (settings.enableAutoEdit) {
                processingSteps.push('Auto-editing content...');
            }

            for (const step of processingSteps) {
                console.log(step);
                await new Promise(resolve => setTimeout(resolve, 2000));
            }

            console.log('Recording processed with AI enhancements:', session.id);
        } catch (error) {
            console.error('Recording processing error:', error);
        }
    };

    const generateAutoContent = async (session: RecordingSession) => {
        try {
            setIsGeneratingContent(true);

            const platforms = ['instagram', 'tiktok', 'youtube', 'facebook'];
            const contentTypes = ['reel', 'story', 'short'];

            const newContent: AutoGeneratedContent[] = [];

            for (const platform of platforms) {
                for (const contentType of contentTypes) {
                    const content: AutoGeneratedContent = {
                        id: `content_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                        type: contentType as any,
                        platform: platform as any,
                        duration: Math.floor(Math.random() * 60) + 15,
                        thumbnail: `https://picsum.photos/300/400?random=${Math.random()}`,
                        status: 'generating',
                        createdAt: new Date(),
                    };

                    newContent.push(content);
                }
            }

            setAutoGeneratedContent(prev => [...newContent, ...prev]);

            await new Promise(resolve => setTimeout(resolve, 3000));

            setAutoGeneratedContent(prev =>
                prev.map(content => ({ ...content, status: 'completed' as any }))
            );

            setIsGeneratingContent(false);

        } catch (error) {
            console.error('Auto content generation error:', error);
            setIsGeneratingContent(false);
        }
    };

    const showAutoGeneratedContent = () => {
        Alert.alert(
            'Auto-Generated Content',
            `Generated ${autoGeneratedContent.length} pieces of content from your photography session:\n\n` +
            autoGeneratedContent.map(content =>
                `${content.platform} ${content.type} (${content.duration}s)`
            ).join('\n'),
            [
                { text: 'View All', onPress: () => {/* Navigate to content library */ } },
                { text: 'OK' }
            ]
        );
    };

    // Riverside.fm functions
    const enterGreenRoom = async () => {
        setIsInGreenRoom(true);
        Alert.alert('Green Room', 'Test your audio and video before joining the photography session.');
    };

    const testAudioVideo = async () => {
        try {
            await new Promise(resolve => setTimeout(resolve, 2000));
            Alert.alert('Test Complete', 'Audio and video are working correctly!');
        } catch (error) {
            Alert.alert('Test Failed', 'Please check your microphone and camera settings.');
        }
    };

    const toggleProducerMode = () => {
        setIsProducerMode(!isProducerMode);
        Alert.alert(
            isProducerMode ? 'Producer Mode Disabled' : 'Producer Mode Enabled',
            isProducerMode ? 'You can now be recorded in the session.' : 'You can control the session without being recorded.'
        );
    };

    const addTeamRole = (userId: string, role: 'host' | 'producer' | 'editor' | 'guest') => {
        const newRole: TeamRole = {
            id: `role_${Date.now()}`,
            userId,
            role,
            permissions: role === 'host' ? ['all'] : role === 'producer' ? ['control', 'edit'] : role === 'editor' ? ['edit'] : ['view'],
            isActive: true,
        };
        setTeamRoles(prev => [...prev, newRole]);
    };

    const startProgressiveUpload = async () => {
        setIsUploading(true);
        setUploadProgress(0);

        const uploadInterval = setInterval(() => {
            setUploadProgress(prev => {
                if (prev >= 100) {
                    clearInterval(uploadInterval);
                    setIsUploading(false);
                    return 100;
                }
                return prev + 10;
            });
        }, 500);
    };

    const editTextBasedVideo = (timestamp: number, originalText: string, editedText: string) => {
        const edit: TextBasedEdit = {
            id: `edit_${Date.now()}`,
            timestamp,
            originalText,
            editedText,
            action: 'replace',
        };
        setTextBasedEdits(prev => [...prev, edit]);
        Alert.alert('Edit Applied', 'Text-based edit has been applied to the photography session.');
    };

    const manageCloudStorage = () => {
        Alert.alert(
            'Cloud Storage',
            `Total Files: ${cloudFiles.length}\nTotal Size: ${cloudFiles.reduce((sum, file) => sum + file.size, 0)} MB\nLast Backup: ${new Date().toLocaleDateString()}`,
            [
                { text: 'View Files', onPress: () => {/* Navigate to file browser */ } },
                { text: 'Backup Now', onPress: () => startProgressiveUpload() },
                { text: 'OK' }
            ]
        );
    };

    const generateInviteLink = async () => {
        if (!currentSession) return;

        try {
            const link = `https://kingdomlens.app/join-recording/${currentSession.id}?type=${settings.recordingType}&max=5`;
            setInviteLink(link);

            Alert.alert(
                'Invite Link Generated',
                'Share this link with your photography clients to join the recording session.',
                [
                    { text: 'Copy Link', onPress: () => {/* Copy to clipboard */ } },
                    { text: 'Share', onPress: () => shareInviteLink(link) },
                    { text: 'OK' },
                ]
            );
        } catch (error) {
            Alert.alert('Error', 'Failed to generate invite link. Please try again.');
        }
    };

    const shareInviteLink = async (link: string) => {
        try {
            await Share.share({
                url: link,
                message: `Join my ${settings.recordingType} recording session: ${link}`,
            });
        } catch (error) {
            Alert.alert('Error', 'Failed to share invite link.');
        }
    };

    const formatTime = (seconds: number): string => {
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        const secs = seconds % 60;
        return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    };

    const renderRecordingControls = () => (
        <View style={styles.recordingSection}>
            <View style={styles.recordingInfo}>
                <Text style={styles.recordingTitle}>
                    {currentSession?.title || 'Ready to Record Photography Session'}
                </Text>
                <Text style={styles.recordingTime}>
                    {formatTime(recordingTime)}
                </Text>
                {isLiveStreaming && (
                    <View style={styles.liveIndicator}>
                        <Text style={styles.liveText}>🔴 LIVE</Text>
                        <Text style={styles.platformText}>
                            Streaming to {settings.liveStreamPlatform}
                        </Text>
                    </View>
                )}
            </View>

            <View style={styles.controlButtons}>
                {!isRecording ? (
                    <TouchableOpacity
                        style={[
                            styles.recordButton,
                            !canRecordVideo && styles.disabledButton
                        ]}
                        onPress={startRecording}
                        disabled={!canRecordVideo}
                    >
                        <Text style={styles.recordButtonText}>
                            {settings.recordingType === 'live-stream' ? '🔴 Go Live' : '📸 Start Recording'}
                        </Text>
                    </TouchableOpacity>
                ) : (
                    <TouchableOpacity
                        style={styles.stopButton}
                        onPress={stopRecording}
                    >
                        <Text style={styles.stopButtonText}>⏹️ Stop</Text>
                    </TouchableOpacity>
                )}

                {isRecording && (
                    <TouchableOpacity
                        style={styles.inviteButton}
                        onPress={generateInviteLink}
                    >
                        <Text style={styles.inviteButtonText}>👥 Invite Clients</Text>
                    </TouchableOpacity>
                )}
            </View>
        </View>
    );

    const renderRiversideFeatures = () => (
        <View style={styles.settingsSection}>
            <Text style={styles.sectionTitle}>Riverside.fm Features</Text>

            {/* Multitrack Recording */}
            <View style={styles.settingRow}>
                <View style={styles.settingInfo}>
                    <Text style={styles.settingLabel}>Multitrack Recording</Text>
                    <Text style={styles.settingDescription}>
                        Separate audio/video tracks per participant for professional editing
                    </Text>
                </View>
                <Switch
                    value={settings.enableMultitrack}
                    onValueChange={(value) => setSettings(prev => ({ ...prev, enableMultitrack: value }))}
                    trackColor={{ false: '#E5E5E5', true: Colors.light.accent }}
                    thumbColor={settings.enableMultitrack ? '#FFFFFF' : '#666666'}
                />
            </View>

            {/* Progressive Upload */}
            <View style={styles.settingRow}>
                <View style={styles.settingInfo}>
                    <Text style={styles.settingLabel}>Progressive Upload</Text>
                    <Text style={styles.settingDescription}>
                        Files upload during session to prevent data loss
                    </Text>
                </View>
                <Switch
                    value={settings.enableProgressiveUpload}
                    onValueChange={(value) => setSettings(prev => ({ ...prev, enableProgressiveUpload: value }))}
                    trackColor={{ false: '#E5E5E5', true: Colors.light.accent }}
                    thumbColor={settings.enableProgressiveUpload ? '#FFFFFF' : '#666666'}
                />
            </View>

            {/* AI Speaker Detection */}
            <View style={styles.settingRow}>
                <View style={styles.settingInfo}>
                    <Text style={styles.settingLabel}>AI Speaker Detection</Text>
                    <Text style={styles.settingDescription}>
                        Auto-layout switching based on who is talking
                    </Text>
                </View>
                <Switch
                    value={settings.enableAISpeakerDetection}
                    onValueChange={(value) => setSettings(prev => ({ ...prev, enableAISpeakerDetection: value }))}
                    trackColor={{ false: '#E5E5E5', true: Colors.light.accent }}
                    thumbColor={settings.enableAISpeakerDetection ? '#FFFFFF' : '#666666'}
                />
            </View>

            {/* Green Room */}
            <View style={styles.settingRow}>
                <View style={styles.settingInfo}>
                    <Text style={styles.settingLabel}>Green Room</Text>
                    <Text style={styles.settingDescription}>
                        Test audio/video before joining the session
                    </Text>
                </View>
                <Switch
                    value={settings.enableGreenRoom}
                    onValueChange={(value) => setSettings(prev => ({ ...prev, enableGreenRoom: value }))}
                    trackColor={{ false: '#E5E5E5', true: Colors.light.accent }}
                    thumbColor={settings.enableGreenRoom ? '#FFFFFF' : '#666666'}
                />
            </View>

            {/* Producer Mode */}
            <View style={styles.settingRow}>
                <View style={styles.settingInfo}>
                    <Text style={styles.settingLabel}>Producer Mode</Text>
                    <Text style={styles.settingDescription}>
                        Control session without being recorded
                    </Text>
                </View>
                <Switch
                    value={settings.enableProducerMode}
                    onValueChange={(value) => setSettings(prev => ({ ...prev, enableProducerMode: value }))}
                    trackColor={{ false: '#E5E5E5', true: Colors.light.accent }}
                    thumbColor={settings.enableProducerMode ? '#FFFFFF' : '#666666'}
                />
            </View>

            {/* Text-Based Editing */}
            <View style={styles.settingRow}>
                <View style={styles.settingInfo}>
                    <Text style={styles.settingLabel}>Text-Based Video Editing</Text>
                    <Text style={styles.settingDescription}>
                        Edit photography session by editing the transcript text
                    </Text>
                </View>
                <Switch
                    value={settings.enableTextBasedEditing}
                    onValueChange={(value) => setSettings(prev => ({ ...prev, enableTextBasedEditing: value }))}
                    trackColor={{ false: '#E5E5E5', true: Colors.light.accent }}
                    thumbColor={settings.enableTextBasedEditing ? '#FFFFFF' : '#666666'}
                />
            </View>

            {/* Auto Leveling & Noise Reduction */}
            <View style={styles.settingRow}>
                <View style={styles.settingInfo}>
                    <Text style={styles.settingLabel}>Auto Leveling & Noise Reduction</Text>
                    <Text style={styles.settingDescription}>
                        Automatically improve audio quality and remove background noise
                    </Text>
                </View>
                <Switch
                    value={settings.enableAutoLeveling && settings.enableNoiseReduction}
                    onValueChange={(value) => setSettings(prev => ({
                        ...prev,
                        enableAutoLeveling: value,
                        enableNoiseReduction: value
                    }))}
                    trackColor={{ false: '#E5E5E5', true: Colors.light.accent }}
                    thumbColor={(settings.enableAutoLeveling && settings.enableNoiseReduction) ? '#FFFFFF' : '#666666'}
                />
            </View>

            {/* Custom Branding */}
            <View style={styles.settingRow}>
                <View style={styles.settingInfo}>
                    <Text style={styles.settingLabel}>Custom Branding</Text>
                    <Text style={styles.settingDescription}>
                        Add logos, overlays, intros, and outros for visual content
                    </Text>
                </View>
                <Switch
                    value={settings.enableCustomBranding}
                    onValueChange={(value) => setSettings(prev => ({ ...prev, enableCustomBranding: value }))}
                    trackColor={{ false: '#E5E5E5', true: Colors.light.accent }}
                    thumbColor={settings.enableCustomBranding ? '#FFFFFF' : '#666666'}
                />
            </View>

            {/* Cloud Storage */}
            <View style={styles.settingRow}>
                <View style={styles.settingInfo}>
                    <Text style={styles.settingLabel}>Cloud Storage</Text>
                    <Text style={styles.settingDescription}>
                        Store photography sessions, assets, and brand kits with encryption
                    </Text>
                </View>
                <Switch
                    value={settings.enableCloudStorage}
                    onValueChange={(value) => setSettings(prev => ({ ...prev, enableCloudStorage: value }))}
                    trackColor={{ false: '#E5E5E5', true: Colors.light.accent }}
                    thumbColor={settings.enableCloudStorage ? '#FFFFFF' : '#666666'}
                />
            </View>
        </View>
    );

    const renderSettings = () => (
        <View style={styles.settingsSection}>
            <Text style={styles.sectionTitle}>Photography Recording Settings</Text>

            {/* Recording Type Selection */}
            <Text style={styles.settingLabel}>Recording Type</Text>
            <ScrollView horizontal showsHorizontalScrollIndicator={false} style={styles.optionsContainer}>
                {recordingTypeOptions.map((option) => (
                    <TouchableOpacity
                        key={option.value}
                        style={[
                            styles.optionCard,
                            settings.recordingType === option.value && styles.optionCardSelected,
                            option.premium && !canLiveStream && styles.premiumOption
                        ]}
                        onPress={() => {
                            if (option.premium && !canLiveStream) {
                                Alert.alert('Premium Feature', 'Live streaming requires an Enterprise subscription.');
                                return;
                            }
                            setSettings(prev => ({ ...prev, recordingType: option.value as any }));
                        }}
                    >
                        <Text style={styles.optionIcon}>{option.icon}</Text>
                        <Text style={[
                            styles.optionTitle,
                            settings.recordingType === option.value && styles.optionTitleSelected
                        ]}>
                            {option.label}
                        </Text>
                        <Text style={[
                            styles.optionDescription,
                            settings.recordingType === option.value && styles.optionDescriptionSelected
                        ]}>
                            {option.description}
                        </Text>
                        {option.premium && (
                            <Text style={styles.premiumBadge}>PRO</Text>
                        )}
                    </TouchableOpacity>
                ))}
            </ScrollView>

            {/* Video Quality */}
            <Text style={styles.settingLabel}>Video Quality</Text>
            <ScrollView horizontal showsHorizontalScrollIndicator={false} style={styles.optionsContainer}>
                {qualityOptions.map((option) => (
                    <TouchableOpacity
                        key={option.value}
                        style={[
                            styles.optionCard,
                            settings.quality === option.value && styles.optionCardSelected
                        ]}
                        onPress={() => setSettings(prev => ({ ...prev, quality: option.value as any }))}
                    >
                        <Text style={styles.optionIcon}>{option.icon}</Text>
                        <Text style={[
                            styles.optionTitle,
                            settings.quality === option.value && styles.optionTitleSelected
                        ]}>
                            {option.label}
                        </Text>
                    </TouchableOpacity>
                ))}
            </ScrollView>

            {/* Audio Quality */}
            <Text style={styles.settingLabel}>Audio Quality</Text>
            <ScrollView horizontal showsHorizontalScrollIndicator={false} style={styles.optionsContainer}>
                {audioQualityOptions.map((option) => (
                    <TouchableOpacity
                        key={option.value}
                        style={[
                            styles.optionCard,
                            settings.audioQuality === option.value && styles.optionCardSelected
                        ]}
                        onPress={() => setSettings(prev => ({ ...prev, audioQuality: option.value as any }))}
                    >
                        <Text style={styles.optionIcon}>{option.icon}</Text>
                        <Text style={[
                            styles.optionTitle,
                            settings.audioQuality === option.value && styles.optionTitleSelected
                        ]}>
                            {option.label}
                        </Text>
                    </TouchableOpacity>
                ))}
            </ScrollView>
        </View>
    );

    const renderRecentSessions = () => (
        <View style={styles.sessionsSection}>
            <Text style={styles.sectionTitle}>Recent Photography Sessions</Text>
            <ScrollView horizontal showsHorizontalScrollIndicator={false}>
                {sessions.map((session) => (
                    <TouchableOpacity
                        key={session.id}
                        style={styles.sessionCard}
                        onPress={() => {/* Navigate to session details */ }}
                    >
                        <View style={styles.sessionHeader}>
                            <Text style={styles.sessionIcon}>
                                {session.recordingType === 'photography' ? '📸' :
                                    session.recordingType === 'tutorial' ? '🎓' :
                                        session.recordingType === 'behind-scenes' ? '🎬' :
                                            session.recordingType === 'live-stream' ? '📡' : '👥'}
                            </Text>
                            <Text style={styles.sessionStatus}>{session.status}</Text>
                        </View>
                        <Text style={styles.sessionTitle}>{session.title}</Text>
                        <Text style={styles.sessionDuration}>{formatTime(session.duration)}</Text>
                        <Text style={styles.sessionDate}>
                            {session.createdAt.toLocaleDateString()}
                        </Text>
                        {session.liveStreamPlatform && (
                            <Text style={styles.platformBadge}>
                                {session.liveStreamPlatform}
                            </Text>
                        )}
                    </TouchableOpacity>
                ))}
            </ScrollView>
        </View>
    );

    if (hasPermission === null) {
        return (
            <SafeAreaView style={styles.container}>
                <View style={styles.loadingContainer}>
                    <ActivityIndicator size="large" color={Colors.light.accent} />
                    <Text style={styles.loadingText}>Requesting permissions...</Text>
                </View>
            </SafeAreaView>
        );
    }

    if (hasPermission === false) {
        return (
            <SafeAreaView style={styles.container}>
                <View style={styles.permissionContainer}>
                    <Text style={styles.permissionTitle}>Permissions Required</Text>
                    <Text style={styles.permissionText}>
                        Camera and microphone permissions are required for photography session recording.
                    </Text>
                    <TouchableOpacity style={styles.permissionButton} onPress={requestPermissions}>
                        <Text style={styles.permissionButtonText}>Grant Permissions</Text>
                    </TouchableOpacity>
                </View>
            </SafeAreaView>
        );
    }

    return (
        <SafeAreaView style={styles.container}>
            <ScrollView style={styles.scrollView} showsVerticalScrollIndicator={false}>
                <View style={styles.header}>
                    <Text style={styles.title}>Photography Studio Recorder</Text>
                    <Text style={styles.subtitle}>
                        Professional photography session recording with Riverside.fm features
                    </Text>
                </View>

                {renderRecordingControls()}
                {renderSettings()}
                {renderRiversideFeatures()}
                {renderRecentSessions()}
            </ScrollView>

            {isProcessing && (
                <View style={styles.processingOverlay}>
                    <ActivityIndicator size="large" color="#FFFFFF" />
                    <Text style={styles.processingText}>Processing with AI...</Text>
                </View>
            )}

            {isGeneratingContent && (
                <View style={styles.processingOverlay}>
                    <ActivityIndicator size="large" color="#FFFFFF" />
                    <Text style={styles.processingText}>Creating photography content...</Text>
                </View>
            )}
        </SafeAreaView>
    );
}

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: Colors.light.background,
    },
    scrollView: {
        flex: 1,
    },
    header: {
        padding: 20,
        alignItems: 'center',
    },
    title: {
        fontSize: 28,
        fontWeight: 'bold',
        color: Colors.light.text,
        marginBottom: 8,
    },
    subtitle: {
        fontSize: 16,
        color: Colors.light.text,
        textAlign: 'center',
        lineHeight: 22,
    },
    loadingContainer: {
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center',
    },
    loadingText: {
        marginTop: 16,
        fontSize: 16,
        color: Colors.light.text,
    },
    permissionContainer: {
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center',
        padding: 20,
    },
    permissionTitle: {
        fontSize: 24,
        fontWeight: 'bold',
        color: Colors.light.text,
        marginBottom: 16,
    },
    permissionText: {
        fontSize: 16,
        color: Colors.light.text,
        textAlign: 'center',
        marginBottom: 24,
        lineHeight: 22,
    },
    permissionButton: {
        backgroundColor: Colors.light.accent,
        borderRadius: 12,
        paddingVertical: 16,
        paddingHorizontal: 32,
    },
    permissionButtonText: {
        fontSize: 18,
        fontWeight: 'bold',
        color: '#FFFFFF',
    },
    recordingSection: {
        marginHorizontal: 20,
        marginBottom: 24,
        backgroundColor: Colors.light.background,
        borderRadius: 16,
        padding: 20,
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.1,
        shadowRadius: 4,
        elevation: 3,
    },
    recordingInfo: {
        alignItems: 'center',
        marginBottom: 20,
    },
    recordingTitle: {
        fontSize: 20,
        fontWeight: 'bold',
        color: Colors.light.text,
        marginBottom: 8,
    },
    recordingTime: {
        fontSize: 32,
        fontWeight: 'bold',
        color: Colors.light.accent,
        fontFamily: 'monospace',
    },
    liveIndicator: {
        alignItems: 'center',
        marginTop: 8,
    },
    liveText: {
        fontSize: 16,
        fontWeight: 'bold',
        color: '#FF0000',
    },
    platformText: {
        fontSize: 14,
        color: Colors.light.text,
    },
    controlButtons: {
        flexDirection: 'row',
        justifyContent: 'space-around',
    },
    recordButton: {
        backgroundColor: '#28A745',
        borderRadius: 12,
        paddingVertical: 16,
        paddingHorizontal: 24,
        flex: 1,
        marginHorizontal: 8,
        alignItems: 'center',
    },
    disabledButton: {
        backgroundColor: '#666666',
    },
    recordButtonText: {
        fontSize: 16,
        fontWeight: 'bold',
        color: '#FFFFFF',
    },
    stopButton: {
        backgroundColor: '#DC3545',
        borderRadius: 12,
        paddingVertical: 16,
        paddingHorizontal: 24,
        flex: 1,
        marginHorizontal: 8,
        alignItems: 'center',
    },
    stopButtonText: {
        fontSize: 16,
        fontWeight: 'bold',
        color: '#FFFFFF',
    },
    inviteButton: {
        backgroundColor: Colors.light.accent,
        borderRadius: 12,
        paddingVertical: 12,
        paddingHorizontal: 16,
        marginTop: 12,
        alignItems: 'center',
    },
    inviteButtonText: {
        fontSize: 14,
        fontWeight: '600',
        color: '#FFFFFF',
    },
    settingsSection: {
        marginHorizontal: 20,
        marginBottom: 24,
    },
    sectionTitle: {
        fontSize: 20,
        fontWeight: 'bold',
        color: Colors.light.text,
        marginBottom: 16,
    },
    settingLabel: {
        fontSize: 16,
        fontWeight: '600',
        color: Colors.light.text,
        marginBottom: 12,
        marginTop: 16,
    },
    settingRow: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'center',
        paddingVertical: 12,
        borderBottomWidth: 1,
        borderBottomColor: '#E5E5E5',
    },
    settingInfo: {
        flex: 1,
        marginRight: 16,
    },
    settingDescription: {
        fontSize: 14,
        color: Colors.light.text,
        marginTop: 4,
    },
    optionsContainer: {
        flexDirection: 'row',
        marginBottom: 8,
    },
    optionCard: {
        backgroundColor: Colors.light.background,
        borderRadius: 12,
        padding: 16,
        marginRight: 12,
        borderWidth: 1,
        borderColor: '#E5E5E5',
        alignItems: 'center',
        minWidth: 120,
    },
    optionCardSelected: {
        backgroundColor: Colors.light.accent,
        borderColor: Colors.light.accent,
    },
    premiumOption: {
        opacity: 0.6,
    },
    optionIcon: {
        fontSize: 24,
        marginBottom: 8,
    },
    optionTitle: {
        fontSize: 14,
        fontWeight: 'bold',
        color: Colors.light.text,
        textAlign: 'center',
        marginBottom: 4,
    },
    optionTitleSelected: {
        color: '#FFFFFF',
    },
    optionDescription: {
        fontSize: 12,
        color: Colors.light.text,
        textAlign: 'center',
    },
    optionDescriptionSelected: {
        color: '#FFFFFF',
        opacity: 0.9,
    },
    premiumBadge: {
        fontSize: 10,
        fontWeight: 'bold',
        color: Colors.light.accent,
        marginTop: 4,
    },
    sessionsSection: {
        marginHorizontal: 20,
        marginBottom: 24,
    },
    sessionCard: {
        backgroundColor: Colors.light.background,
        borderRadius: 12,
        padding: 16,
        marginRight: 16,
        minWidth: 200,
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 1 },
        shadowOpacity: 0.1,
        shadowRadius: 2,
        elevation: 2,
    },
    sessionHeader: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'center',
        marginBottom: 8,
    },
    sessionIcon: {
        fontSize: 24,
    },
    sessionStatus: {
        fontSize: 12,
        color: Colors.light.text,
        textTransform: 'capitalize',
    },
    sessionTitle: {
        fontSize: 16,
        fontWeight: 'bold',
        color: Colors.light.text,
        marginBottom: 4,
    },
    sessionDuration: {
        fontSize: 14,
        color: Colors.light.accent,
        fontFamily: 'monospace',
        marginBottom: 4,
    },
    sessionDate: {
        fontSize: 12,
        color: Colors.light.text,
    },
    platformBadge: {
        fontSize: 10,
        fontWeight: 'bold',
        color: Colors.light.accent,
        marginTop: 4,
        textTransform: 'uppercase',
    },
    processingOverlay: {
        position: 'absolute',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: 'rgba(0, 0, 0, 0.7)',
        justifyContent: 'center',
        alignItems: 'center',
    },
    processingText: {
        color: '#FFFFFF',
        fontSize: 16,
        marginTop: 16,
    },
}); 